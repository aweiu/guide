{"./":{"url":"./","title":"️介绍","keywords":"","body":"Regular指南 API文档已经与本文档合并，可在索引章节查看 安装 请参考 项目github主页说明 命名约定 为了描述简便，本文档做以下命名约定。 Component: 所有Regular和继承自Regular的组件 component(小写): 所有Component的实例 Expression: 表达式 关于模板管理 本文档的模板是使用多行模板字符串管理的，如果你需要在低版本的浏览器中使用，请使用 Webpack等构建工具 或 '\\' 转义折行书写。 贡献文档 除了直接fork此项目，发起 Pull Request，你也可以通过在线编辑来帮助修复细小的错误。 "},"intro/what.html":{"url":"intro/what.html","title":"Regular是什么","keywords":"","body":"Regular是什么 Regular 本身在网易公司内部稳定运行了超过4年(本节撰写于2018年), 支持了数十条产品线，可靠性是值得保证的。 Regular 是 MDV(数据驱动视图技术) 的一种实现， 它... 提供以下能力 数据绑定,局部刷新 深度的组件化能力 服务端渲染 单页系统：regular-state提供完整的单页系统解决方案，包括服务端渲染支持 编译到小程序: 感谢考拉团队精彩的 mpregular 拥有以下特性 语法灵活：自建DSL，表达能力不受HTML语法所限 基于脏检查：直接操作裸数据，没有 set/get 包装 良好的兼容性：支持 IE7+ 以及其他现代浏览器 渐进的视图层框架：无侵入性，可以配合任何框架和模块系统使用 "},"intro/hello.html":{"url":"intro/hello.html","title":"️你好，Regular","keywords":"","body":"你好，Regular 我们即将实现一个简单的登录组件：HelloRegular。 初始结构 //利用Regular构建你的app吧 const HelloRegular = Regular.extend({ template: ` Hello, {username} ` }); // initialize component then $inject to #app's bottom const component = new HelloRegular({ data: { username: 'leeluolee' } }); component.$inject('#app'); See the Pen HelloRegular by leeluolee (@leeluolee) on CodePen. 说明 Regular.extend(definition) 创建一个继承自 Regular 的组件， definition 对象的属性会成为此组件的 原型属性。 template 这个范例模板中使用了 {} 插值语法 data 组件实例的初始化数据可以通过data属性传入。 $inject(node[, direction]) 实例方法$inject可以将组件插入到目标节点的指定位置 bottom[默认参数]：作为 node 的 lastChild 插入 top：作为 node 的 firstChild 插入 after：作为 node 的 nextSibling 插入 before：作为 previousSibling 插入 使用条件展示 接下来我们在模板中使用if/else语句处理未登录的情况 {#if username} Hello, {username}. {#else} Sorry, Guest. {/if} See the Pen HelloRegular-2 by leeluolee (@leeluolee) on CodePen. 绑定事件处理逻辑 直接在节点上声明 on-click 绑定click事件 {#if username} Hello, {username}. Logout {#else} Sorry, Guest. Please Login {/if} tips: Regular 中 on-开头的属性会被作为事件绑定处理，每当对应的ui事件触发。会将传入的表达式运行一次 这里我们添加了两个用户操作: 登出 ：Regular 的表达式支持赋值操作，这里的登出我们仅仅是对 username 做了清空处理。 登录 ：模板中的 this对象指向实例component本身，我们需要在extend时添加一个原型方法login()来处理登录逻辑。 login: function(){ var data = this.data; // get data data.username = prompt(\"please enter your username\", \"\") } See the Pen HelloRegular-2 by leeluolee (@leeluolee) on CodePen. 下一步阅读 我们直接从 Regular 中最重要的概念 - 组件开始吧 如果你对数据如何驱动视图变更的，也可以查看数据监听章节 "},"basic/":{"url":"basic/","title":"基础","keywords":"","body":"入门 "},"basic/component/":{"url":"basic/component/","title":"️组件","keywords":"","body":"组件 - component 「组件化」不仅仅是标签化这种表现层面的描述 在用户端开发领域，组件应该是一种独立的、可复用的交互元素的封装。 Regular的组件满足以下等式 组件 = 模板 + 数据 + 业务逻辑 提示 本节会简单涉及到 DOM事件 组件基础 使用 Component.extend 定义一个可复用的组件 const Component = Regular.extend( { template: ` 你点了{count}次按钮 `, config( data ){ data.count = 0; } }); extend 返回的是一个组件构造函数，你可以直接使用 new 关键字进行实例化 new Component().$inject(document.body) new Component().$inject(document.body) //可以重复使用 参考 api - $inject: 插入组件到指定节点位置,或恢复组件到游离状态（脱离文档） 声明式调用 除了通过new实现命令式初始化，Regular 支持在别的组件模板中使用声明式调用，这是最常见的使用方式。 // 注册名为Component的全局组件 Regular.component('Component', Component) new Regular({ template:` ` }) 效果与上例完全一致 参考 api - Component.component: 组件注册 全局别名快捷设置 - name 因为上例这种注册到全局的方式比较普遍, Regular 支持在 extend 时，直接设置别名 Regular.extend({ name: 'Component' // 设置全局别名 //... }) 组件的参数传入与绑定 data 在 Regular 中是个特殊的实例属性，根据 索引：表达式 所述 数据根路径从 component.data 开始,即 {user} 其实获取的是 component.data.user 实际上在模板里也可以拿到实例上的其它属性，比如 {this.nickName} 拿到的就是实例上的nickName字段，例如 new Regular({ template:` {this.nickName} {userName} `, nickName: 'leeluolee', data: { userName: 'hzzhenghaibo' } }) 这样看起来，似乎 data 仅仅只是个短写的语法糖而已。 其实不尽然，因为 只有data上的字段可以通过声明式属性传入 就相当于 new Component({ data: { title: 'hello' } }) 节点属性会自动成为data对象上的字段。 参数传递细节说明 传入属性都会成为data的成员 相当于data.total='100', data.title='Hello' 注意非属性插值，则传入类型都是字符串 插值创建双向绑定 如果存在插值则会双向绑定，如下例的title与外层的title字段就形成了双向绑定 例外：在这里 show={true} 比较特殊，因为表达式是一个静态值，所以不会产生双向绑定。 value 缺省,则默认成为Boolean值true 上例相当于 连缀格式转驼峰 则 show-modal 会转换为 showModal， 但是 isHide 这种驼峰式的写法仍然支持，并不做变换 事件指令 满足on-[eventName]的属性会自动转换为组件事件绑定 其它特殊属性 特殊属性如ref和isolate 会有特殊的功能。请参考 获取内部节点和组件 和 组件隔离 禁止在extend中定义缺省data参数 ⚠️不要在 extend 或 implement 时定义data属性 !!! ，这会导致所有实例共享数据。 const Component = Regular.extend({ name: 'Component', template: ` {title} 点击shared.count+1: {shared.count} 点击instance.count+1: {instance.count} `, data: { shared:{ count:1 // 会影响到所有实例 } }, config(data){ data.instance = {count: 1} // 每个实例独有 } }) // 每个实例独有 参考 风格指南：禁止在 extend 中定义缺省 data 参数 生命周期钩子 Regular 提供了几个常用的生命周期钩子，你可以实现指定方法来处理自定义逻辑 config( data ) - 在模板编译前调用 Regular.extend({ config( data ){ data.title = data.title || '默认标题' } }) data: 合并传入参数后的data对象 参考 参数传递 init - 在模板编译后调用 在这个阶段，已经可以获取到生成的节点，但是仍然是游离状态的，未插入到实际DOM节点中 Regular.extend({ template: `Hello`, init(){ console.log(this.$refs.container.innerHTML === 'Hello'); //true } }) 参考 获取子节点和子组件 destroy - 在组件销毁前调用 销毁函数 , 注意 如果要自定义回收函数，务必调用父类 destroy(this.supr)来销毁掉一些通用部分(如事件监听，数据监听) const Component = Regular.extend({ init(){ this.onScroll = function(){}; window.addEventListener('scroll', this.onScroll) }, destory(){ this.supr(); // 千万别忘记 window.removeEventListener('scroll', this.onScroll) } }) modifyBodyComponent 请参考 @TODO 生命周期图示 实例化时 销毁时 动态组件 Regular 提供了 r-component 用于处理动态组件的需求，这个组件使用is属性来决定使用什么组件来渲染 is: 组件名 如下例，我们预先定义了MarkdownRender 与 HtmlRender两个组件 Regular.extend({ name: 'MarkdownRender', template: ``, config(data){ this.$watch('content', (content)=>{ data.mdcontent = marked(content) }) } }) Regular.extend({ template: ``, name: 'HtmlRender' }) 使用r-component来动态实例化组件，注意is属性是个动态插值 使用markdown 是否使用mdrender 参考 其余属性都会成为指定组件的data参数，请参考组件参数小节 数据监听 父组件 - $parent 在 Regular 中，声明式实例化的组件都具有一个this.$parent属性，它指向直接父组件 const Example = Regular.extend({ name: 'Example', init(){ console.log(this.$parent.name) // log 'App' } }) const App = Regular.extend({ name: 'App', template: `` }) const main = new Regular({ template: ``, data: { title: 'main title' } }) 直接父组件，决定了子组件执行的数据上下文。比如App接受的title实际指的是main.data.title，而Example的title则指向app.data.title(App的实例)。 组件隔离 默认情况下，父子组件之间会建立双向绑定 即我在上层组件修改一份数据会导致pager也进行了脏检查，而pager发生数据变化也会引起上层组件发生脏检查，这在有些时候不是我们想看到的，也会影响到组件的整体性能。我们或许希望pager与上层组件完全隔离，而完全通过事件来通信。 组件的isolate属性 isolate可以实现上述要求，例如上例如果修改为: 那内嵌组件pager与实际就是完全隔离了，完全等同于JS初始化new Pager().$inject('input', 'after')。 获取子节点和子组件 获取到组件内部的子组件和子节点是使用 Regular 的常见需求。 常见DOM操作的误区 组件本身应该是完全数据驱动，dom操作应该交由指令处理 在理念上并没有错，但有时直接操作DOM会简单很多。所以经常有人在 init 中写出以下代码(此时内部节点已经产生) Bad Case Regular.extend({ template: ``, init: function(){ const elem = document.getElementById('xxx'); 返回null } }) 这种做法并不会凑效，因为 init 时此组件并没有插入到文档中，游离状态的组件自然无法用document.getElementById获取到它。 但我们可以使用 ref 来解决 ref 属性 ref 是个特殊的属性，你可以使用它来标记一个节点或组件. const component = new Regular({ template: \" \" init: function(){ this.$refs.input.value = 'hahaha' this.$refs.component.show() // 调用子组件的方法 } }) 如上例所示，在 compile 之后(比如 init 生命周期里)，就可以使用this.$refs 来获取到内部子节点或子组件了。 还是应尽可能使用数据驱动的方式来构建你的UI ref属性是可动态插值 ref属性与其它属性一样可以插值，这样在类似循环渲染的场景中会比较有用 Regular.dom.element 获取组件的子节点。 除了ref，Regular还提供了 dom.element(component, needAll) 可用于获取组件内部的节点。 const dom = Regular.dom; const component = new Regular({ template: `` init: function(){ console.log(dom.element(this)) // => div#first console.log(dom.element(this, true)) // => [div#first, p#last] } }) 说明 如果needAll为true，返回子节点数组。 何时使用dom.element 何时使用 ref? ref 的优点是简单直观而且高效，除此之外还可以 获取组件 。 而 dom.element 的优势是不需要做主动的标记，可以提供ref无法满足的能力，例如 const Component = Regular.extend({ template: 'Component' init: function(){ this.$refs.container // ... } }) // SubComponent 继承自 Component const SubComponent = Component.extend({ 'template': 'SubComponent' }) 这就会出现问题，因为SubComponent覆盖的模板并没有标记 container 节点。本质其实是因为 模板的控制权不在当前组件 。 这个时候就可以使用dom.element就可以完美解决了 const Component = Regular.extend({ template: 'Component' init: function(){ console.log(dom.element(this)); } }) // SubComponent 继承自 Component const SubComponent = Component.extend({ 'template': 'SubComponent' }) 其它事项 没有单节点限制 Regular 的模板和一些框架不同，它没有单节点限制，在描述结构时可以更加自由 Regular.extend({ template: ` Hello, {username} Nice to meet you ` }) 此时默认使用 Regular.dom.element 将只能获取到第一个节点，如果你需要获取到所有节点可以传入第二个参数，此时将返回包含所有节点的数组 Regular.dom.element(component, true); "},"basic/interpolation.html":{"url":"basic/interpolation.html","title":"️插值","keywords":"","body":"插值 插值是Regular最常用特性，包括 文本插值 - 针对文本节点 属性插值 - 针对DOM节点 参数插值 - 针对声明式组件 Fragment参数 - 片段参数 他们语法都是类似，即{Expression}，{}也称为表达式容器。 参考 其他场景也可以使用表达式，具体参考表达式使用场景 文本插值 举例: {username} 针对文本插值，Regular 会创建一个 textNode, 并建立表达式到textContent的 单向数据绑定 Example const app = new Regular({ template: \"{username}\", data: {username: 'leeluolee'} }); app.$inject('#app'); 上面的例子会输出leeluolee，并且一旦数据发生改变，文本节点内容也会发生改变 由于是单向绑定，你直接修改textContent是无法反向映射到数据的，而且会导致单向绑定失效 属性插值 举例: haha 针对属性插值，Regular 会创建一个对应名称的属性节点，并创建表达式到 属性值 的单向绑定。 几个注意点 如果文本内部具有插值符号{}, Regular 会解释成组合表达式，如'.modal-{klass} z-{state}' 就相当于是 '.modal-' + klass + 'z-' + state。 对于非指令类的的属性, Regular 会在值变化时, 修改对应属性, 即一般属性(class, style，title等)是天生可插值的。 对于指令类的属性, Regular 会将具体处理逻辑交由指令处理。 由于是单向绑定，你通过 DOM API 修改属性值是无法反向映射到数据的，而且会导致单向绑定失效 Example 上述几个属性结果如下 r-model: 参考内置指令 style: 字符串组合插值, 等价于 \"left: \" + value + \"px\" class: 简单属性插值 type: 简单属性赋值，没有绑定 FAQ Regular中，class不是关键字，你可以直接使用 部分接受对象类型的指令如 r-style，请注意r-style={'left': '10px'} 是错误的赋值，因为'left': '10px'不是合法表达式，{{'left': '10px'}}才是正确的写法 参数插值 举例: 通过参数插值传入组件数据，并创建外层组件字段(如上例 blog.title )到内部组件字段(如上例 title)的 双向绑定 注意如果表达式不是setable的(如 title={blog.title + ':' + blog.subTitle}), 将只会创建外层组件到内层组件的 单向绑定 关于参数插值，请直接看组件章节 Fragment片段参数 Regular还支持一种模板片段的插值，称为，它与组件结构的复用能力直接相关，如 我是标题 } > 我是内容区 更多解读请直接参考组合 - 结构复用 "},"basic/event.html":{"url":"basic/event.html","title":"️事件","keywords":"","body":"事件 Regular 中事件分为两类 DOM事件 组件事件 在大部分情况下，它们的使用方式和表现一致。 DOM 事件 DOM节点上 所有以 on- 开头的属性都会被当做DOM事件处理 基础DOM事件 Syntax : on-event={Expression} 每次event触发时，表达式 Expression 都会被运行一次 Example: count+1 {count}, 如果表达式执行后的值为false(===)，事件的默认行为将会被阻止，当然你也可以通过$event.preventDefault()来阻止事件的默认行为。 自定义DOM事件 比如on-tap, on-hold Usage Component.event(event, fn) Arguments event: 自定义事件名 fn(elem, fire) elem: 被绑定节点 fire: 触发事件函数 注意如果需要做 销毁工作 ，与指令一样，你需要在 fn 中返回一个函数用来做销毁工作 Example 定义 on-enter 事件处理回车逻辑 var dom = Regular.dom; Regular.event('enter', function(elem, fire){ function update(ev){ if(ev.which == 13){ // ENTER key ev.preventDefault(); fire(ev); // if key is enter , we fire the event; } } dom.on(elem, \"keypress\", update); }); Tip: 模板中出现的 this 指向组件实例本身，回车后会运行实例的submit方法 查看 $event了解更多 注意：除非是自定义事件，其它事件无论浏览器是否支持，都会通过addEventListener进行绑定 事件代理支持 on-*会在当前节点绑定事件，在某些情况下（比如大列表），这种方式不是很高效。 在这种情况下，我们可以尝试使用 delegate- 代替 on-，来避免潜在的性能问题，delegate- 只会绑定一次事件到 父节点 上 Example Delte //Proxy way via delegate Delte // Evaluated way via delagate 但是，需要注意的是，delegate- 并非是「银弹」 避免在高频触发的事件中使用( 比如 mouseover )，这样反而会产生性能问题 事件必须可冒泡 自定义事件请参考 zepto tap-event 的实现. 部分事件天生没法冒泡，比如 IE 低版下的 change，select 等 $event 对象 $event 会在每次事件触发时注入到 data.$event 中，你可以直接在模板里使用它。 Example $event对象是被修正过的，在兼容 IE6 的前提下，你可以使用以下规范内的属性 origin: 绑定节点 target: 触发节点 preventDefault(): 阻止事件默认行为 stopPropagation(): 阻止事件冒泡 which pageX pageY wheelDelta event: 原始事件对象 对于自定义事件，$event 即传入 fire 触发器的对象 组件事件 Regular 集成了一个轻量级的 Emitter，使得所有组件实例都可以使用以下接口来实现事件驱动的开发 component.$on: 用于添加事件监听器 component.$off: 用于解绑事件监听器 component.$emit: 用于触发某个事件 Example 模板里声明组件事件绑定 与DOM事件绑定类似，声明式组件以 on- 开头的属性都会被视作事件绑定 假设已经注册了一个名为 Pager 的翻页器组件 每当 Pager 组件通过 $emit 抛出nav事件，对应的 this.refresh($event) 就会被调用，执行组件上的 refresh 方法 是的，整个过程和 DOM 事件并无二样。但其中的 $event 代表 $emit 传入的第一个参数 内建生命周期内的组件事件 Regular 会在组件实例初始化过程的关键阶段抛出事件 $config: 会在 compile 之前触发 $init : 会在 compile 之后触发，此时，dom 结构已经生成，你可以通过 this.$refs 来获取了 $destroy: 会在组件被 destroy 时触发 $前缀是为了标识内建事件 事件的共性 组件和DOM事件具有共性 事件绑定语法 表达式(e.g. on-click={this.remove()}) 如果传入的是表达式，该表达式会在事件触发时被运行一次。 Example Delte 这是一种最标准的写法，大多数时候你只会用到它 非表达式（e.g. on-click=\"remove\"） 简化写法，等价于 on-click={this.$emit('remove', $event)} ，事件会以同样的事件名和参数被再次抛出，相当于做了一次代理 Example 事件的不同点 组件事件由 $emit 方法抛出，而 DOM 事件由浏览器抛出 DOM 事件由于 DOM 本身的特点，是可以冒泡的，而组件事件没有冒泡的机制 $event 在组件事件中是 $emit 传入的第一个参数，而在 DOM 事件中是封装过的事件对象 完整的事件绑定流程 "},"basic/statement/":{"url":"basic/statement/","title":"️语句","keywords":"","body":"语句 Regular 除了插值和表达式之外的语法元素就只有语句 Syntax {#NAME ...}Block..{/NAME} 或者自闭合语句 {#NAME /} 目前 rgl 中只有三类语句: list, if/else/elseif 和 include，未来也会通过相同的语法来进行扩展 😀 迭代的结构不受单节点限制 与大部分其它框架不同的是，包裹在rgl语句包裹结构不限制一个唯一节点内 ，如下例的list语句 new Regular({ template: ` {#list items as item} {item_index}-{item.name} {/list} `, data: { items: [{ name: 'Apple' }, { name: 'Android' }, { name: 'Windows' } ] } }).$inject(document.body) ⚠️ Regular中 语句和XML标签是不能被相互打断的 😔错误️ {#if true} True {#else} False {/if} 😀正确 {#if true} True {#else} False {/if} "},"basic/statement/list.html":{"url":"basic/statement/list.html","title":"️列表渲染 - list","keywords":"","body":"列表渲染 - list list语句用来根据列表或对象选项进行循环渲染。 Example {#list sequence as item} {item.name} {/list} 说明 sequence: 求值为数组或对象的表达式 item: 迭代数组元素的别名 下标 {别名}_index 每次迭代会创建一个名为 {别名}_index 的下标别名，下标从 0 开始。 Example const component = new Regular({ template: ` {#list items as obj} {obj_index}:{obj} {/list} `, data: { items: [\"a\", \"b\", \"c\", \"d\"] } }) component.$inject(document.body); 输出 0:a 1:b 2:c 3:d #else语句展示空状态 嵌入#else语句来来展示列表 为空 的情况 [], null, undefined 都会视为是空值 Example {#list list as item } {item} {#else} no result here {/list} 使用 track语句 加速你的列表渲染 默认条件下，Regular会使用莱文斯坦编辑距离算法来计算最小变更DOM。 但这个算法的时间复杂度是 O(n2) ，在列表超过一定数量时(比如 >100 )，它的逻辑开销就会明显超过DOM的开销。 所以Regular 提供了by 描述符来精确控制DOM的销毁与复用 使用 Syntax {#list sequence as item by Expression} {/list} Expression: 任意表达式(如item.id)，⚠️记得每个迭代的表达式求值应该是唯一不重复的 Example by 下标 最常用的场景就是直接track下标,这种在内部是最快的实现，因为没有任何排序和对比开销。 注意点 track复用的节点不会重新调用组件的生命周期流程（config、init)，只是简单的更新迭代别名对应的值。 ⚠️track不能应用在对象的列表渲染中，因为对象本质是无序的。 在超大列表下，尽可能的使用下标track，达到最佳的性能效果。 对象的列表渲染 Regular 支持对象类型的列表渲染渲染 键的别名变量 {别名}_key 在对象的列表渲染中，假设循环别名是item, 各别名的意义分别是 item: 迭代的对象值 item_key: 迭代的对象键 item_index: 迭代的下标 Example 解决对象渲染无法track 上节提到了对象是无法进行track的，你可以先将其转换为有序, 再使用track描述 也可以在JS中转换为数组 要点提示 与其它语句一样，list语句包裹的结构不受单节点限制 "},"basic/statement/if.html":{"url":"basic/statement/if.html","title":"️条件渲染 - if","keywords":"","body":"条件渲染 - if Regular提供了if，elseif，else等语法元素来做条件渲染的控制 Syntax {#if condition} ... {#elseif condition2} ... {#else} ... {#if} 说明: condition: 判断条件Expression，这个表达式结果会被强制转换为Boolean值 Example {#if user.age >= 80 } you are too old {#elseif user.age if 语句不是条件渲染的银弹 在Regular内部，if语句在每次切换时会回收掉隐藏的部分，创建需要展示的部分。某些场景用其它方案做条件渲染会更高效。 表达式 还是 if语句？ 其实上例可以修改为用表达式 this.getInfo(user.age)，这样的开销更少，而且复杂逻辑抽离到JS中，会让模板更清晰。 r-hide 还是 if语句? Regular 提供了 r-hide 指令用来控制节点的display属性，实际上也能做到条件渲染。 有几个建议，你参考是选择 r-hide 还是 if语句 如果控制展示区域不复杂或者有 高频率控制展示隐藏的部分，请选择r-hide，这样可以避免重复的回收/创建开销。 其它情况请选择if语句，因为if语句会将整个区域都进行回收，对内存会比较友好 要点提示 与其它语句一样，if语句包裹的结构不受单节点限制 "},"basic/statement/include.html":{"url":"basic/statement/include.html","title":"️结构引入 - include","keywords":"","body":"片段渲染 - include include语句可用来引入动态的渲染片段 Syntax {#include template} template : 求值结果是 String 或 AST 使用 直接参考组合 - 结构复用章节 "},"reference/expression.html":{"url":"reference/expression.html","title":"表达式","keywords":"","body":"表达式 \bRegular里所有的绑定都与表达式有关，表达式编译结果是一个表达式对象, 熟悉本章内容可以帮助你更好的理解Regular内部的数据监听原理。 ES5 表达式 Regular 支持几乎所有 ES5 表达式语法，下列都是合法的表达式 100 + 'b'. user? 'login': 'logout' title = title + '1' !isLogin && this.login() items[index][this.nav(item.index)].method1() 几个注意点 表达式中的this指向组件本身 数据根路径从 component.data 开始, 即user 其实获取的是component.data.user 不支持自增、自减(++,--)以及位操作符& |等 不支持正则表达式的字面量 开放了部分JS内建对象: Array Date JSON Math NaN RegExp Object String decodeURI decodeURIComponent encodeURI encodeURIComponent parseFloat parseInt 除了 ES5 的表达式，Regular 还提供了以下几种表达式类型 规范外表达式类型 一次性绑定 脏检查性能依赖于监听器的数量，Regular引入了@()预发提供了一次绑定功能： 监听器在一次变更后就会被移除。 syntax @(Expression) 可以在任意的表达式环境使用@()(list, if... etc) Example { @(title) } // the interpolation only trigger once {#if @(test)} // only test once //... {/if} {#list @(items) as item} // only trigger once //... {/list} 你也可以在$watch 使用 @() var component = new Regular({ data: { user: {} } }); var i = 0; component.$watch(\"@(user.name)\", function(){ i++ // only trigger once }); component.$update(\"user.name\", 1); component.$update(\"user.name\", 2); // update twice but trigger once alert(i === 1); 如上例所示，由于『脏了一次就被被抛弃』, 如果值后续继续变化，会导致UI与数据不同步。 参考 API: $update 过滤器Filter syntax Expression| fitlerName: arg1, arg2,... argN Example 假设已注册 format 过滤器 {list|format: 'yy-MM-dd'} 参考指南 过滤器 Range Range 即数组的简写模式 Syntax: start..end Example 1..3 === [1,2,3] 错误抑制 在动态模板中，如果抛出所有JS中常见的 xx of undefined 的错误，整个系统会变得相当脆弱。Regular 抑制了这类错误中安全的部分，并使用undefined代替 new Regular({ template: \"{blog.user.name}\" }) // => 如果是方法不存在产生的错误，Regular 仍然会抛出，这属于「非安全」的错误 new Regular({ template: \"{this.methodNoFound(blog.user.name)}\" }) 其中blog.user.name错误被抑制，而this.methodNoFound的未定义错误会被抛出 表达式对象 理解表达式对象，可以帮助你使用表达式 表达式在编译后会通过new Function编译为一个 表达式对象 ，对象包含以下两个关键方法 get(context) 即表达式的求值函数，函数需要传入context(Component实例)参数 Regular的脏检查即通过比较get两次返回是否不同来判断数据是否变动。 example: // create expression var component = new Regular({ data: { user: 'leeluolee', age: 20 } }); var expr = component.$expression(\"user + ':' + (age - 10)\") alert(expr.get(component) === \"leeluolee:10\" ) //true set(context, value) *此函数不一定存在 如果表达式是一个合法的LeftHandSideExpression，Regular会提取set函数，用来赋值，set函数通常用于实现双向绑定。 // component as context var component = new Regular({ data: { users: [ {name: 'leeluolee'}, {name: 'luobo'} ], index:0 } }); var expr = component.$expression('users[index].name') expr.set(component, 'daluobo'); alert(component.data.users[0].name === 'daluobo') // true 可以提取出set函数的表达式，我们称此表达式是 setable 的，如果一个不是setable的表达式应用与双向绑定(如 r-model)结合使用，将不能得到应有效果。 并不是所有表达式都可以提取出set，即代表了不是所有表达式都能完成双向绑定，比如表达式「a+b」，显然虽然我们可以获取它的值，但是我们无从知晓如何去设置a和b的值。 表达式的可用场景 文档中，标记为Expression类型的场景都可以使用表达式。 插值 语句 if list include 允许传入Expression的某些API如 $watch $update $expression "},"basic/data-binding.html":{"url":"basic/data-binding.html","title":"数据监听","keywords":"","body":"数据监听和计算属性 大部分情况，通过在模板中声明表达式，Regular 会通过 vm 自动完成 view 与 model 的绑定，对于自定义的监听需求，你可以通过 数据监听实现 在本文的末尾，也有对数据绑定原理：脏检查的介绍。 Regular 内部的所有监听都是通过 $watch API， 你也可以使用这个 API 来实现自定义数据监听 基本用法 new Regular({ template: ` `, config( ){ this.$watch('value', value=>{ this.data.value = value.slice(0, 5); }) } }) 这个例子实现了 最多只能输入5个字符 的效果。 深度监听 通过传入deep: true 可以做到对象的深层监听 new Regular({ template:` {blogStr} `, config(data){ data.blog = {title: '', content: ''}; this.$watch('blog', (blog)=>{ // blog.title or blog.content is change data.blogStr = JSON.stringify(blog) }, { deep:true }) } }) 注意 Regular 目前只能监听一级属性，太复杂的属性建议使用不变数据结构，或 监听序列化后的值的方式 ( 通过JSON.stringify，这种方式仅针对数据不是太复杂的场景 ) this.$watch('JSON.stringify(blog)', (blogStr)=>{ const blog = this.data.blog; // blog is change }) 直接触发本监听的脏检查 你可以直接通过init:true参数，强制触发当前监听器的脏检查，而不用等待下一轮 $digest 流程 Regular.extend({ init(){ this.$watch('blog', ()=>{ console.log('同步检查这个watcher') },{ init: true }) console.log('晚于watch回调执行') } }) 数据监听的秘密 - 脏检查 类似Angular ，Regular 的数据绑定基于脏检查实现。 脏检查即一种不关心你如何以及何时改变的数据，只关心在特定的检查阶段数据是否改变的数据监听技术。 本节包含内容 什么是脏检查 脏检查是如何进行的 何时进行脏检查 为什么选脏检查 监听器的稳定性 统一使用 Angular 生态圈的术语，方便开发者理解 什么是脏检查 以文本插值 {post.title}为例，在compile阶段，Regular 内部的处理逻辑如下。 walkers.expression = function( expression ){ var node = document.createTextNode(\"\"); this.$watch(expression, function(newval){ dom.text(node, \"\" + (newval == null? \"\": \"\" + newval) ); }) return node; } 这段代码很好理解: 遇到文本插值时，Regular 会创建一个 textNode，每当数据变化时，修改 textNode 的 textContent 值。 说明 expression: 表达式: 即post.title，反映在组件就是component.data.post.title. $watch: 添加一个数据监听器(watcher对象) 那么问题来了，怎么判断值发生改变了？ 脏检查如何进行 - digest流程 首先，上例通过$watch接口产生的watcher对象看起来是这样的 { get: function(context){...} //获得表达式当前求值，此函数在解析时，已经生成 set: function(){} // 有些表达式可以生成set函数，用于处理赋值，这个一般用于双向绑定的场景 once: false // 此监听器是否只生效一次，如 {@(expression)} last: undefined// 上一次表达式的求值结果 fn: function(newvalue, oldvalue){} // 即你传入$watch的第二个参数，当值改变时，会调用此函数 // ... } 这是必须引出内部的重要阶段 - digest阶段 ，当系统进入此阶段时，将会进行数据检查，它的处理流程如下: 标记 dirty = false 遍历数据观察者watcher，一旦有监听器值发生改变，就标记dirty=true 检查一轮后，如果 dirty===true ，我们重新进入步骤1. 否则进入步骤4. 完成脏检查 checkSingleWatcher 先来看下简化后的检查单个监听器逻辑 checkSingleWatcher function checkSingleWatcher( watcher ){ let newValue = watcher.get( this ) if( newValue !== watcher.last ) { watcher.fn( newValue, watcher.last ) watcher.last = newValue } return false } checkWatchers 下例是简化后的检查所有监听器的逻辑 function checkWatchers( isStable ){ var watchers = isStable? this._stableWatchers : this._watchers; var children = this._children; var dirty = false; // 只要有一个监听器有变化，则认为dirty watchers.forEach( watcher=>{ if( checkSingleWatcher(watcher) ) dirty = true }) //递归遍历所有子组件的监听器 children.forEach( comp=> { if(comp.checkWatchers(isStable)) dirty = true }) return dirty; } 好，现在我们了解数据检查的内部流程了，但是何时进入digest阶段 何时进行脏检查 由于脏检查没有任何数据劫持逻辑(比如Vue)，数据模型本身是无状态的，所以是无法得知数据的变更时机的，可以猜测 digest 阶段必然是 主动进入的 。 在 Regular 中，digest 阶段是由$update方法触发的。 Example var component = new Regular(); component.data.name = 'leeluolee' // you need call $update to Synchronize data and view component.$update(); 值得庆幸的是，大部分情况下都会自动进入 digest 阶段。比如事件、timeout 模块等等。 {blog.title} 为什么使用脏检查 脏检查完全不关心你改变数据的方式，而常规的set, get的方式则会强加许多限制 脏检查可以实现批处理完数据之后，再去统一更新view. 脏检查其实比 GET/SET 更容易实现。脏检查是个单向的检查流程(请不要和双向绑定发生混淆)，可以实现_任意复杂度的表达式支持。而get/set的方式则需要处理复杂依赖链，基本上表达式支持都是阉割的(使用时就像踩雷). 但脏检查有时是低效的，因为每次检查都会无脑的遍历（Regular已经对Loop做了优化）。 但与MVVM结合时，他又是高效的。因为数据监听模式带来了DOM的局部更新(而且是准确更新，而不是Virtual DOM那样需要做 diff-patch 操作)，而DOM操作恰恰又是隐藏的性能瓶颈所在。 监听器的稳定性 Regular 的数据监听器分为两类 不稳定的监听器: 即监听器回调运行可能导致别的数据变动，此时我们应该再进行$digest流程，才能判断值是否真的稳定this.$watch('title', (title)=>{ this.data.summary = title.slice(0, 10); }) 这个监听器触发变更时，会导致summary的字段的变更。 稳定的监听器: 即回调运行不会导致别的数据变动，比如大部分内部实现的指令和插值等监听器this.$watch('title', (title)=>{ this.$ref.container.setAttribute('data-title', title); }) 这个监听器触发变更时，只是修改了DOM，但并不影响别的字段 实际Regular的脏检查流程是 检查不稳定监听器直到稳定 检查 一次 稳定的监听器 你也可以通过\b传入stable:true来标记这个监听器是稳定的，来得到更好的性能表现 Example this.$watch('title', (title)=>{ this.$ref.container.setAttribute('data-title', title ); }, {stable: true}) "},"basic/filter.html":{"url":"basic/filter.html","title":"计算字段与过滤器","keywords":"","body":"计算字段与过滤器 \b\bRegular 提供了两种自定义表达式读写的方式 —— 计算字段 和 过滤器 计算字段 计算字段在 options 通过 computed 字段注册，可以避免书写冗余的表达式 计算字段的定义 使用计算字段相当于手动构造 表达式对象 对象包含get和set(可选)方法， get(data): 属性的 getter 函数，定义 读 逻辑 data: data 指向 component.data this: this 指向组件 component set(value, data): 属性的 setter 函数，定义 写 逻辑 value: the value to set data: data 指向 component.data this: this 指向组件 component 其中set是可选的 const Component = Regular.extend({ computed: { fullname: { get: function(data){ return data.first + \"-\" + data.last; }, set: function(value, data){ var tmp = value.split(\"-\"); data.first = tmp[0]; data.last = tmp[1]; } } } }) 直接传入函数，它会作为getter函数存在 const Component = Regular.extend({ computed: { fullname: function(data){ return data.first + \"-\" + data.last; } } }) 上例你也可以简写成一个表达式 const Component = Regular.extend({ computed: { fullname: `first+ '-' + last` } }) 完整的使用范例 const Component = Regular.extend({ template: ` fullname: first: last: {welcome} `, computed: { welcome: `'Hello, '+ fullname`, fullname: { get: function(data) { return data.first + \"-\" + data.last; }, set: function(value, data) { const tmp = value.split(\"-\"); data.first = tmp[0]; data.last = tmp[1]||''; } } } }) const component = new Component({ data: { first: '1', last: '2' } }).$inject(document.body); 说明 welcome: 只读的计算字段 fullname: 由于设置了set，是可读可写的计算字段，可用于双向绑定 计算字段的读写 如果你需要在 javascript 对定义的计算进行读写会失败，因为要兼容低版本IE，计算字段并非通过Object.defineProperty实现，不过 Regular 提供了途径来获取计算字段 -- $get const Component = Regular.extend({ computed:{ fullname: `first + '-' + last` } }) const component = new Component({ data: { first: 'Zheng' last: 'Haibo' } }); console.log(component.data.fullname) // undefined console.log(component.$get('fullname')) // 'Zheng-Haibo' 实际上 $get 也可以应用与所有表达式。 component.$get('\"Hello, \" + fullname') 参考 $get 计算字段范例: 「全选/反选」 const ListComponent = Regular.extend({ computed: { selectAll: { // only every item is selected, we return true get: function( data ){ if(!data.list) return false; return data.list.filter( function(item){ return !!item.selected} ).length === data.list.length; }, set: function( value, data ){ if(!data.list) return // set every item.selected with passed value data.list.forEach(function(item){ item.selected = value; }) } } } }) template {#list list as item} {item.text} {/list} Select All 过滤器 - filter 过滤器是 Regular 中的一种扩展表达式类型 , 你可以和+、-符号一样去使用它。 Syntax Expression| fitlerName: arg1, arg2,... argN Example {list| join: '+'} 定义过滤器 你可以通过Regular.filter来定义一个过滤器。 下例会定义一个join数组为字符串的，它接受一个split参数 Regular.filter({ 'join': function( list, split ){ return list.join(split||'-') } }) new Regular({ template:` {list|join:'+'} `, data: { list: ['Add', 'Update', 'Delete'] } }) 过滤器参数 过滤器参数可以传入任意个，他们会依次传入到过滤器定义的get和 set 函数中，过滤器参数可以是任意表达式 Reuglar.extend({ template:` {list|join:'+'} ` }) 过滤器的优先级 过滤器是一个优先级小于三元表达式(如 a?b:c )的表达式，与标准表达式一样，你可以使用()来提升它的优先级 { 'add: ' + ([1,2,3]|join: '+') } = 6 输出 add: 1+2+3 = 6 日期格式化过滤器: format 以下实现了一个简化的 Regular 日期过滤器 Example 创建一个简单的日期格式化过滤器 // simplest date format function fix(str) { str = \"\" + (str || \"\"); return str.length 然后 {time| format: 'yyyy-MM'} 双向过滤器 Regular 支持一个简单的概念: 双向过滤器，使得过滤器可以代理写操作，与计算字段类似，你需要理解一个表达式对象实际是由 get(读操作) 和 set (写操作) 构成 双向过滤器如其名，经常会用在双向绑定上，由于这个特性，r-model可以变相与一个数组类型实现双向绑定。 以 {[1,2,3]|join: '-'} 为例 过滤器定义 Regular.filter('join', { //[\"1\",\"2\",\"3\"] - > '1-2-3' get: function(origin, split ){ return origin.join( split || \"-\" ); }, // **Important ** // '1-2-3' - > [\"1\",\"2\",\"3\"] set: function(dest, split ){ return dest.split( split || \"-\" ); } }) 说明: 过滤器定义传入函数，则自动成为 get 读函数 {JSON.stringify(array)} 说明 过滤器劫持了读写，使得字符串类型和数组变相实现了双向绑定。 写过程: 从表单元素的input.value 到数据 array，先经过 set 函数，从 字符串 > 数组 读过程: 从数据array到表单元素的input.value ，先经过 get 函数，从 数组 > 字符串 如表达式章节所述, 部分全局变量如JSON在模板中可用 过滤器与计算字段的对比 过滤器是一个可复用的抽象，而计算字段是一个写死的字段定义 计算字段使用更简洁 内置过滤器 为了控制框架体积，Regular 只有少量内置过滤器，其中 不包含format! ，你参考上例实现，或直接使用更详细的包，例如 moment.js json: 这是一个双向过滤器 get: JSON.parse set: JSON.stringify last get: list[list.length-1] "},"basic/directive.html":{"url":"basic/directive.html","title":"️指令","keywords":"","body":"指令 - directive 指令是 针对DOM节点 的功能增强。 注意：所有指令都只能在DOM节点上使用， 无法在组件上使用 使用指令 当 Regular 解析到一个属性时，例如 ，会根据属性名去检查它是否是一个指令（通过Component.directive定义） 如果是: 则完全交由指令处理 如果否: 则视为普通属性 上例中，r-html 就是一个指令， title则是一个普通属性插值。 定义指令 初始化：directive.link(elem, value, name, extra) 每一个组件可以通过Component.directive来扩展指令，其中最关键的就是 link 方法，它用来处理指令的启动 以下面的html的插值指令为例(实际上这也是内部r-html的实现), innerHTML会相应数据的变更 Regular.directive('html', { // elem指向当前节点，value即传入属性值 link( elem, value ){ this.$watch(value, val => { elem.innerHTML = val; }) } }) 参考 数据监听 使用 注意这里 Regular 指令的命名是没有要求的，但建议工程中有一个统一前缀来区分于普通属性 指令属性值说明 这里需要说明的是，属性值即 指令link 的第二个参数，有三种可能 属性不是插值，r-html='blog'，则入参即为对应字符串如'blog.title' 属性是插值，即类似r-html={blog.title}，value是一个 Expression对象 当没有值，如 则传入'' (空字符) 你可以根据自己的需要作对应的判断 更新逻辑：directive.update(elem, value, oldValue, extra) 由于绝大部分场景都如上例 类似，只需要处理数据变更的情况，此时可以选择更简洁的update方法 Regular.directive('html', { update(elem, value){ elem.innerHTML = value } }) 是不是简便了许多？ 说明 如果传入值是表达式(如{blog.title})，update会在 初始化 和 值变更时 触发 如果是空或文本，update会只在初始化触发一次，不会产生绑定 ⚠️ 在0.6.0版本以前, Regular有一个已知Bug —— update 函数必须在link函数存在时才会生效，所以至少需要定义一个空的link函数 指令参数: directive.param param: 指令的参数属性名的配置 有些场景，指令可能需要辅助的参数，Regular 支持指令声明式依赖其他属性作为参数 例如，用html指令实现一个超出指定字符就显示...省略符号的需求 Regular.directive('html', { param: ['limit'], update(elem, value, oldvalue, extra){ const limit = parseInt( extra.param.limit, 10); const htmlStr = value.length > limit? htmlStr.slice(0, limit) + '...': value; elem.innerHTML = htmlStr; } }) extra.param即我们接受的参数集合的对象。 说明 指令参数目前没有变更的监听函数，所以无论是否传入的是表达式，都只有初始值 指令参数属性将不会进入正常属性的流程 link 和 update 都接受extra参数 指令销毁 如果你的指令需要销毁逻辑，比如在指定启动时，引入了全局状态，只需要在link函数中返回一个Function即可 Regular.directive(\"lazy-load\", function(){ document.addEventListener('scroll', onScroll); return function (){ document.removeEventListener('scroll', onScroll); } }) 上例中我们直接传入了函数，这是一种简写方式，此函数会成为指令定义的link函数。 Question: 为什么要返回销毁函数，而不是通过监听 $destroy事件来完成？ Answer: 因为指令的销毁并不一定伴随着组件销毁，指令的生命周期更短，一些语法元素会导致它在组件销毁之前被重复创建和销毁： if / else / elseif list include 不过值得庆幸的是，一切关于数据监听的事务，都无需回收，比如你在link函数内部通过this.$watch进行了数据绑定，Regular 会进行自动收集。 属性解析的流程示意图 参考 基础:事件 内建指令 移步索引:内建指令 指令优于DOM操作的原因 因为 组件概念 以及语句的存在，Regular 中指令的作用被大大弱化，但是 对于针对具体节点的功能性增强 ，仍然推荐使用指令来解决，而不是手动的操作DOM。原因如下： 指令是一种可复用的抽象， 亦如Regular中的r-model指令，如果手动实现，你仍然需要大量的代码 声明式的指令理解起来更加直观 "},"basic/animation.html":{"url":"basic/animation.html","title":"️动画","keywords":"","body":"动画系统 声明式动画绝对是所有MDV框架都面临的痛点，大部分框架都只处理了节点进入退出的场景。Regular的动画系统非常轻量级（代码量上），但是有很强大的实现，看看它的过人之处吧。 本页方便起见依赖 animate.css 来实现CSS3动画效果 动画简介 你可以通过r-animation指令来实现动画。 Syntax Sequence: Command (\";\"\" Command)* Command: CommandName \":\"\" Param; CommandName: [-\\w]+ Param: [^;]+ Exmaple 点我动起来 上例的意思是: 当 click 触发时 为元素添加类名 animated swing，当 transitionend (或 animationend)触发时，移除它们 等待 500ms. 与第二步类似 动画结束 done。(由于移除的添加的样式，节点会重新出现) 可以看到，一个单独节点的缓动序列是由一系列的 Command 构成的， 先看看内建的Command吧 内建Command Regular 内建了多个Command，其中比较特殊的是 on 和 when，它们是唯二的用于激活动画开始的Command on: event 当特定的 event 触发时开始动画，event可以是当前节点的DOM事件，也可以是所在组件的事件。 注意: Regular会先去检查event是否是个DOM事件，如果不是，则会转而监听组件事件 为实现渐入渐出效果，Regular 提供两个模拟事件 enter: 在节点进入时触发 leave: 在节点退出时触发 (动画结束后，节点才会被真正移除) 以下情况导致的节点进入退出会触发这两个事件 r-hide指令 if语句 list语句 include语句 component.$inject Example {#list items as item} {item.content} {/list} when: Expression 当表达式为真触发动画 当component.data.status为1时，会触发此动画效果。 class: classes, mode class是基于CSS3的动画Command，它会等待动画结束之后(transitionend 或 animationend)，再执行后续效果。 参数 classes: 空格分割的 className mode (Number): 添加 class 的模式 Command: class的形为取决于 mode参数，一共有四种 mode. 1: 默认 mode，首先加指定类名到节点，当动画结束移除它 2: 首先添加 class 到节点，然后在 nextTick 添加class-active到节点用以触发动画，当动画结束移除所有类名 3: 与 mode1 类似，但是动画结束后，我们不移除类名 4: 移除指定类名，并等待动画结束。 example box1 box2 box3 每当点击box1, box2 或 box3. 它们分别会产生不同的效果 box1: 添加 animated fadeIn 等待 animationend 移除它们 box2: 添加 animated fadeIn 添加 animated-active fadeIn-active at next-tick(to trigger the animation) 等待 animationend 然后移除所有 animated fadeIn animated-active fadeIn-active box3: 添加 animated fadeIn 等待 animationend，动画结束 emit: event 抛出某个事件，注意这可能会触发另一个动画序列（被命令 on 捕获） box1: trigger by click box2: after box1 swing box1 通过抛出 swing-over 事件触发了box2的动画。 call: expression 运行一个表达式并进入脏检查，注意，与emit类似，这里可能会触发另外一个动画序列(被命令when捕获) box1: trigger by checkbox box2: after box1 swing 流程描述 当 test == true 激活box1的动画 swing动画结束之后，设置otherSwing=true 这个导致box2的动画序列开始 box2 swing box1也在进行shake style: propertyName1 value1, propertyName1 value1 ... 设置样式并且等待 transitionend（如果可以触发的话） example style: click me 添加 transition 来触发的缓动动画 .box.animated{ transition: color 1s linear; } 这个例子的意思是: 一旦点击，swing动画。 结束后设置color:#333(激活transition动画)... 步骤结束后，进行bounceOut动画。 设置display:none 动画序列结束 wait: duration 等待若干毫秒后再进入下一个步骤 param duration: 一个毫秒为单位的整数。 wait: click me 扩展动画 上例基本都依赖CSS3的动画，如果需要更精细的动画控制，或是需要兼容不支持CSS3的浏览器，可以通过Component.animation接口扩展你的动画Command（上述所有Command都基于此接口实现） 参数 name(String): 命令名 handle(step): 序列命令定义，你需要在handle中返回一个函数 step.element: 即上述element对象 step.param: 即上述param 返回值[Function]: handle函数必须返回一个动画处理函数，它接受一个参数done用来结束当前动画。 Example 实现一个渐入渐出的效果 Regular.animation(\"fade\", function(step){ var param = step.param, // 传入fade的参数 element = step.element, //触发节点 fadein = param === \"in\", ratio = fadein? 1.05: 0.9; // 这个函数会在每次本步骤被触发时被调用， // 它只接受一个done函数作为参数，标志着本步骤的结束 return function(done){ var start = fadein? 0.01: 1; var tid = setInterval(function(){ start *= ratio if(fadein && 1- start 使用 fade: click me ⚠️当你定义的动画结束时，必须调用这个done函数，否则永远进入不了下一个动画步骤 查看内建命令(github:animation.js#L71)的实现来理解扩展动画 Command 小贴士: 其实r-animation 不仅仅限于应用动画，它其实是个支持声明式表述的状态机，你可以利用它来实现一些异步序列。 跨节点的复杂动画序列 这是一个显示肌肉但不被推荐在真实场景使用的例子 可能相对于其他声明式的框架，Regular 的动画声明的写法上会繁琐一些，但是带来了无限的可能性，结合数据监听体系和事件系统，事实上你可以在 Regular 中实现任意复杂度，跨越任意节点的动画序列！ Example 小节 由于声明式动画的天然限制，不要奢求其对动画的控制力可以达到手动JS编码的自由度(比如使用velocity.js)。如果有难以实现且不可复用的场景，直接操作DOM来完成吧。 建议优先使用事件来完成动画序列的串联。 "},"advanced/":{"url":"advanced/","title":"深入组件","keywords":"","body":"深入组件 组件是 Regular 的灵魂，经过基础章节，其实不难看出，所有诸如指令、模板、事件等配套其实都是为了实现一个组件的完整功能而引入的。 Regular的组件就像一个小型的MVVM模式的闭环，它拥有独立的生命周期，但是组件组合使用时，情况会复杂一些。 这一章，我们会进入组件概念的细枝末节中，将会是你与『Regular初学者』彻底划清界限的章节。 "},"advanced/modular.html":{"url":"advanced/modular.html","title":"继承与模块化","keywords":"","body":"模块化 - 基于原型继承 大型工程里，对于封装隔离性会有较高的要求。Regular 提供了基于原型继承的工程化隔离方案。在文章开头，会先介绍下 Regular 的继承体系。 Regular的继承体系 Regular.extend Regular 的类式继承简化自 ☞ded/klass, 只保留了其中两个接口。 extend: 从父组件派生一个可重用组件 implement: 扩展当前组件的原型对象 与 klass 的相同点 Regular.extend 返回一个构造函数此构造函数拥有以下特点 返回子类同时也拥有extend, implement方法。 const Component = Regular.extend({ say: function(){}, run: function(){} }); const SubComponent = Component.extend(); SubComponent.implement({ run: function(){ } }) 在方法中可以通过this.supr()来调用父类的同名函数 const ChildComponent = Component.extend({ say: function(){ this.supr() // call Component.prototype.say. console.log(\"sub say\"); // other logic } }) ChildComponent.implement({ run: function(){ this.supr() // call Component.prototype.run } }) var component = new ChildComponent(); component.run（); Tips:使用exend、implement之外的方式扩展的原型方法无法使用this.supr() 与klass的不同点 由于extend同时又是组件定义的接口，所以在extend时，Regular同时会做一些预处理操作: 预解析传入的template参数。保证由这个类的模板只会被解析一次。 子类同时拥有 component, directive, filter, event, animation函数，用来扩展组件功能 如果定义时传入了 name，则为此组件注册组件名，使得可以以 内嵌组件 的形式使用此组件 const Modal = Regular.extend({ name: 'Modal' }) 这些伴生逻辑 也决定了，当前版本下无法使用纯粹 ES6 的 class 来实现 Regular 组件定义 组件的功能扩展以及命名空间 根据 API文档 的介绍，我们知道了所有 Regular 组件都支持这几种扩展 filter：过滤器扩展 directive：指令扩展 event：扩展一个自定义事件 animation：扩展一个新的动画command component：注册组件，使其可以声明式使用 implement: 扩展组件的实例方法或属性 这些扩展都有以下特点 即是 set 又是 get 方法 上述5个接口其实是由一个工厂函数产生，简单示意如下例所示 function factory(){ const cache = {}; return function(name, definition){ if(typeof definition === 'undefined') return cache[name] cache[name] = definition } } Regular.directive = factory(); 所以，扩展定义可以使用同名接口获取 const filter1 = { set(){ }, get(){ } } Regular.directive('filter1', filter1) console.log(Regular.directive('filter1') === filter1) // true 单向影响性 这几位的共同特点就是 扩展只对定义它的Component及其子类可见 如 Regular.event('tap', tap) var Child = Regular.extend(); var SubChild = Children.extend(); Child.event('tap2', tap2) alert( Regular.event('tap') === tap ) // Child's extension will not affect Parent alert(Regular.event('tap2') === undefined) alert(Child.event('tap') === tap) alert(Child.event('tap2') === tap2) // but affect SubChild alert(SubChild.event('tap2') === tap2) // filter，directive is the same 即父类无法获得子类定义的扩展，而反之可以，这个最基本的概念是实现 Regular 的模块化的第一步。 对于implement无需多做解释，这是原型继承的基本原理，而对于其它几个接口，是通过定义的原型继承Object.create()来实现的 单向影响性 是实现封装隔离性的第一步。 建立项目内独立的隔离空间 对于建立独立的隔离空间，聪明的同学可能已经想到了: 即定义一个不会被实例化的组件来替代Regular顶层空间。 var YourNameSpace = Regular.extend() YourNameSpace.filter().directive().event() //.... var Component = YourNameSpace.extend(); 这样，独立项目内的扩展就不会影响到产品中的其它Regular组件了，而扩展自NameSpace的组件可以拥有所有组件内的功能扩展。 Regular模块 基于上述描述，如果将一系列过滤器、指令、事件作为一个整体封装起来，就可以称之为是一个独立的功能模块。 一个典型的模块可以这样书写。 function FooModule(Componenet){ Component.implement()// implement method .filter() // define filter .directive() // define directive .event() // define custom event } var YourComponent = Regular.extend(); FooModule(YourComponent); // bind(局部) FooModule(Regular); // bind(全局) 为了更统一，Regular提供了一个use方法来统一'使用'模块，如上例可以写成 // 局部 YourComponent.use(FooModule); // 全局 Regular.use(FooModule); Regular预定义模块 预定义模块都可以直接用Component.use('模块名')的方式使用 模块名: '$timeout' timeout模块在组件中扩展了两个方法 Number $timeout(fn, delay): 定时器函数(setTimeout)，在fn调用会进入本组件的数据检查，返回计时器id Number $interval(fn, delay): 周期定时器函数(setInterval)，在fn调用后会进入本组件的数据检查，返回计时器id timeout模块非常简单，简单到可以直接列出全部源码 function TimeoutModule(Component){ Component.implement({ $timeout: function(fn, delay){ delay = delay || 0; return setTimeout(function(){ fn.call(this); this.$update(); //enter digest }.bind(this), delay); }, $interval: function(fn, interval){ interval = interval || 1000/60; return setInterval(function(){ fn.call(this); this.$update(); //enter digest }.bind(this), interval); } }); } Example 一个简单的计数器 const Counter = Regular.extend({ template: ` {count} start stop`, start: function() { if (this.tid) return; this.tid = this.$interval(function() { this.data.count++; }, 500); }, stop: function() { this.data.count = 0; clearInterval(this.tid) this.tid = null; } }).use('$timeout'); // 小结 经过本章的学习，我们理解了 每一个Regular组件类都拥有以下类方法用来定义或扩展组件能力 extend implement directive filter event animation component use 扩展都具有单向性限制，使得以上 都只会作用于本组件或子类组件 鉴于这个单向性，我们可以在每个工程中定义一个“命名空间”来实现本工程对外的隔离性 对于作为整体的扩展需求，我们可以定义一个模块，并使用use来使用这\u001b个模块 "},"advanced/composite.html":{"url":"advanced/composite.html","title":"️组合 - 结构复用","keywords":"","body":"结构复用 如果说 组件 是 Regular 的核心，那 组合 就是 Regular 核心中的核心 通过上述章节的学习，我们明白可以轻松的使用基于类的继承体系来实现 数据 和 逻辑 的复用或重写，那如何做到结构的复用呢？ 这里我们引入一个\b本章贯穿的例子 - Card Card 即一个卡片的展示组件，为了复用，它需要两个可配置的部分：标题 和 内容区 {title} {content} 我们使用预埋的 {title} 和 {content} 可以实现 Card组件的标题和内容的 文本覆写， 问题: 可扩展性太差，比如「内容区需要富文本展示」或「标题区需要配置Icon」就无法满足了。 解决:可以使用HTML插值r-html来实现静态结构的重写需求 r-html - 静态结构复用 使用 new Regular({ template:` Card标题' content={content} /> `, data:{ content: ` 这是Card内容区一 这是Card内容区二 ` } }) 这里遗留一些问题，如片段无法使用事件、指令、语句、插值等等功能，本质因为r-html引入的内容是不经过编译的。 局部模板可以帮助我们解决这个难题。 局部模板复用 类似于Handlebars的Partials, Regular 中可以使用 include 语句来实现局部模板引入 Example const Card = Regular.extend({ template:` {#include partialTitle} {#include partialContent} ` }) 这里，我们重新定义一个新的组件 IconCard ,使得自定义icon的逻辑可以复用。 const IconCard = Card.extend({ name: 'IconCard', config(data){ data.partialTitle = `{title}` this.supr(data); } }) 使用 new Regular({ template:` 这是Card内容区' /> ` }) 看似并没有什么节省代码，但当被复用的局部模板比较大时，收益就很客观了，而且可以避免暴露无关的细节。 局部模板的上下文 局部模板的上下文与使用它的组件一致，\b在声明式调用时可能会产生混淆。 Example 假设有如下一个 App 组件，其中 Card 与上节定义\b一致。 const App = Regular.extend({ template:` `, config( data ){ data.partialTitle = '标题' data.partialContent = '内容:{content}' }, clickContent(){ alert('App 点击内容') } }) const app = new App({ data: { content: 'App Content' } }).$inject('body'); 由于事件绑定和文本插值实际上都没有指向app, 而是指向内部的Card组件实例，所以没有达到需要的效果。 针对这个问题，Regular 提供另一种include的使用方式，类似于其他框架的slot插槽。 内嵌内容 - this.$body 什么是内嵌内容? 内嵌内容即被当前节点包裹的内容，例如我们日常书写的HTML One Two 的内嵌内容就是它的childNodes，即 One Two 而对于 Regular 而言，内嵌内容也是类似，即 被组件标签所包裹的内容 {content} 其中{content}即组件Card的内嵌内容，在组件里你可以通过this.$body来使用它 使用内嵌内容 还是以Card为例，仍然使用 include 语句，但是引入内容修改为this.$body。 {#include title} {#include this.$body} const App = Regular.extend({ template:` {content} `, clickContent(){ alert('点击内容') } }) const app = new App({ data: { content: 'App Content' } }).$inject('body'); 这里，我们发现如我们之前所期待\u001b的，事件和文本绑定都指向了App。 这是因为 被引入的内嵌内容的上下文指向声明它的组件，类似我们的词法作用域，取决于定义的地方，这样更符合我们的使用直觉 Fragment 在Regular中，类似this.$body表现的数据类型，我们称之为 Fragment。 使用Fragment达到结构复用目的行为被称为组合 我们已经知道，内嵌内容会成为组件的实例属性$body, 但它也决定了每个组件只能声明一个内嵌内容，如果我们需要使用多个Fragment该怎么办？ 你可以通过{~ }插值来实现任意个数的Fragment引入。 Fragment插值 {~} Example 以上节例子为基础，我们可以这样传入title const App = Regular.extend({ template:` 测试标题 } > {content} `, clickContent(){ alert('点击内容') }, clickClose(){}{ alert('点击关闭') } }) const app = new App({ data: { content: 'App Content' } }).$inject('body'); Fragment插值的效果与内嵌内容完全一致。 视觉父节点 参考以下例子 const Icon = Regular.extend({ name: 'Icon', template:` ` }) const App = Regular.extend({ template:` 我是标题 } > 我是内容区 ` }) 上例中，因为App内声明的和的上下文是一致的，他们的直接父组件$parent都是App。 问题：如何获得实际使用它(通过#include语句)的组件呢？ this.$outer 如果一个组件是通过Fragment的方式使用，组件实例存在一个$outer属性指向使用它的组件，我们称之为 视觉父组件。 有别于 直接父组件，他们之间没有直接的数据关系(但可能存在间接关系)。 const Icon = Regular.extend({ name: 'Icon', template:` `, init(){ console.log(this.$outer.name) ; //Log Card } }) "},"advanced/modify.html":{"url":"advanced/modify.html","title":"️动态注入","keywords":"","body":"实例化劫持 Regular在v0.6版本引入了新生命周期hookmodifyBodyComponent，这个hook用来劫持到内部组件的实例化动作。 modifyBodyComponent( component, next ) component: 内部实例化的组件 next( component ): 决定是否调用上层嵌套的modifyBodyComponent 起步 const EventBusProvider = Regular.extend({ name: 'EventBusProvider', config(){ const emitter = new Regular; this.$broadcast = emitter.$emit.bind(emitter) this.$subscribe = emitter.$on.bind(emitter) }, modifyBodyComponent( component ){ // 为组件注入这个全局的事件中介者 component.$broadcast = this.$broadcast; component.$subscribe = this.$subscribe; } }) 这样内部包裹的所有组件（包括组件的子组件）都可以使用到EventBus ⚠️ 这个hook在compile 之后，但在init之前触发 const Button = Regular.extend({ name: 'Button', template: ` JUST Button `, config(){ console.log('before compile: ' + this.$broadcast) // undefined }, init(){ console.log('after compile: ' + this.$broadcast) // Function } }) new Regular({ template: ` ` }).$inject('body') 条件控制 我们发现一个问题，这样所有的内部组件都会被劫持修改，如何限制在某些条件下才注入呢？ 你可以通过 标记 的方式来选择被注入的组件 modifyBodyComponent( component ){ // 只有被marked标记的组件会被劫持注入 if( component.data.marked ){ component.$broadcast = this.$broadcast; } } 使用 这样就只有会被注入了 使用next参数控制嵌套的modifyBodyComponent 很多有时候，会有嵌套的 默认情况下，Button不会被处理， 但你可以通过modifyBodyComponent的第二个参数进行控制 const EventBusProvider = Regular.extend({ name: 'EventBusProvider', config(){ const emitter = new Regular; this.$broadcast = emitter.$emit.bind(emitter) this.$subscribe = emitter.$on.bind(emitter) }, modifyBodyComponent( component, next ){ // 为组件注入这个全局的事件中介者 component.$broadcast = this.$broadcast; component.$subscribe = this.$subscribe; // ⚠️通过next调用的位置，即调用OtherProvider#modifyBodyComponent的位置 next(component) } }) 注意点 通过next来调用上层的modifyBodyComponent逻辑 你可以控制next的调用位置来控制外层修饰器的执行位置（之前、之后） 下一步阅读 如果你暂时不知道如何应用modifyBodyComponent，请参考专题：组件通信 "},"topic/":{"url":"topic/","title":"专题","keywords":"","body":"专题 一个具体场景或问题的解决方案可能会涉及到多个知识点或外部依赖，这些解决方案或最佳实践会放到专题章节，本章会包含以下内容: 模板管理: 除了指南中的ES6多行模板字符串，你还可以有其他选择，包括有些同学需要的单文件组件.rgl 单页系统: 大部分应用场景都是单页系统，由于篇幅过长，此章节直接独立为外部《单页系统指南》 服务端渲染: 使用Regular的服务端渲染增强SEO和首屏体验 微信小程序 mpregular告诉你如何将代码同时编译到微信小程序 性能指引: 旨在用20%的精力解决80%的Regular性能问题，里面有关于脏检查的更深入描述 "},"topic/template.html":{"url":"topic/template.html","title":"模板管理","keywords":"","body":"如何优雅的管理你的模板 作为一个『库』，Regular肯定不会涉及到模板的加载，你只需保证传给template的值是个字符串或是预解析AST即可。 也就是说，所有可以加载纯文本的方式都可以用来加载Regular的模板。 Regularjs本身已经提供了尽可能多的方式来方便你在不同的场景下都能管理你的模板。 方案清单: 简单方案 直接字符串拼接 在容器节点中保存模板 依托ES6或Coffeescript的多行字符串 与模块化工具结合的方法 webpack browserify NEJ requirejs 使用Regular.parse实现解析插件 使用单文件组件rgl 简单管理方案 在regularjs提供的所有例子中，为了方便起见，基本都使用了以下两种方式来管理你的模板: 直接在js中声明模板字符串 {#raw} var Component = Regular.extend({ tempalte: \"{title}\" }) 当模板非常简单时，这样做确实非常方便， 当模板结构稍微复杂点时，一般也可以使用页面的模板容器节点 引用页面节点里的内容 {#script} var Component = Regular.extend({ tempalte: document.getElementById(\"app\") }) 在#app节点(一般是修改了type的script标签，即不会render其中内容的容器): //... //... 这种方式相较于方式1其实有利有弊。例在于它解决了在js中拼接字符串模板的肮脏行为，弊则在于模板本身变成了一个「全局」的东西，组件这个统一的整体也被打碎了，从项目规模庞大后，维护这些散落在页面中的容器节点也会成为随时引爆的导火索 使用多行字符串 {#mult} 大家都知道ES6和coffee都可以直接使用多行字符串，免去了字符串拼接的开销 ES6 var template = ` {content} ` 鉴于现在ES6的打包工具普及度非常高，非常推荐开发者直接使用ES6进行开发 对于ES5或ES3，其实也有一种小技巧来帮助我们书写多行字符串——sindresorhus/multiline 你可以这样来声明一个多行字符串 var str = multiline(function(){/* ❤ unicorns */}); 但是！！，不建议大家在实际项目中使用这种提取注释的方式来书写，因为注释是可能会被压缩工具移除的。 上述简单管理方案都有一些小问题，即无法对模板做预解析(除非在超大项目，否则parser的开销相较于实例化是较小的) 『 是否有解决上述问题的方案呢？』 答案是肯定的，即将模板作为一种资源集成到模块系统中 Regular模板与模块系统结合 下面会介绍Regular与市面上常见模块系统的结合方案，它们分别是 webpack: ES6 或 Commonjs 或 AMD (一统浆糊) broswerify: Commonjs NEJ: 类AMD规范( 网易杭州的前端模块规范 ) requirejs: AMD 本文只是介绍如何将Regular集成进这些系统中，而不是普及这些模块系统的使用方法，请大家自行学习。 webpack webpack是近年来兴起的当红炸子鸡，支持多种模块规范共存，支持增量编译，社区强大。作者非常推荐直接使用ES6 + webpack的方式来开发你的项目。 webpack对于非内建模块支持，是通过自定义loader的方式。 ✨所有DEMO可以在regularjs/example 找到范例 配置 var path = require('path'); module.exports = { entry: \"./src/index.js\", output: { path: __dirname , filename: \"bundle.js\" }, module: { loaders: [ { test: /\\.html$/, loader: \"raw\" }, { test: /\\.rgl$/, loader: 'rgl' }, // In fact, we can use template string for keep regularjs template. { test: /\\.js$/, loader: 'babel?cacheDirectory'} ] } }; 使用 import tpl from './login.html'; import Regular from 'regularjs'; const LoginBabel = Regular.extend({ name: 'login-babel', template: tpl }) export { LoginBabel } 上述代码列举了两种方式 raw-loader 加载纯文本模板 小贴士: 事实上如果你使用了babel-loader 就可以直接使用多行字符串来管理你的模板，无需配置raw-loader rgl-loader 加载并与解析模板 browserify browserify在前些年几乎是唯一的『bundle-all-in-one』同步模块打包方案(即使这种方案算是不温不火)，它依托了NPM以及Commonjs(你仍然可以通过书写transform来支持其他模块标准)来构建自己的生态圈。 同样的，你可以通过两种transform来实现对Regular模板的加载。 var html2string = require('browserify-html2string'); browserify-html2string 配置 var browserify = require('browserify'); var html2string = require('browserify-html2string'); browserify(['./src/index.js'], {}) .transform(html2string) // 使用html2string transform .pipe(source('bundle.js')) .pipe(gulp.dest('public/js')) 模块写法 var tpl = require(\"foo.html\"); var Component = Regular.extend({ template: tpl }) regularify Regular提供一个browserify的transform:regularify，它可以用来处理两种格式rglc和rgl(后缀都是可配置的). 配置 browserify(['./src/index.js'], {}) .transform(html2string) // you can have multiply transform in one building .transform(regularify({ END: '}', BEGIN: '{' })) .pipe(source('bundle.js')) .pipe(gulp.dest('public/js')) 模块写法 var tpl = require(\"foo.rgl\"); var Component = Regular.extend({ template: tpl, // .... }) 点击regularify主页了解更多 NEJ 对于网易的同事(特别是杭研)，由于是近水楼台的原因，regularjs已_直接集成进了NEJ框架及其配套打包工具之中。与上述任意工具一样，你可以通过两种方式 text!：纯文本加载 define(['text!path/to/foo.html', 'path/to/regularjs'], function(tpl, _p){ var Foo = Regular.extend({ name: 'foo', template: tpl }) return Foo; }); regular! 预解析 define(['regular!path/to/foo.html', 'path/to/regularjs'], function(tpl, _p){ var Foo = Regular.extend({ name: 'foo', template: tpl }) return Foo; }); ⚠注意由于Regular本身打包的是UMD格式，对于非Commonjs和AMD格式的统一是以全局变量的方式，所以Regular无法在模块系统中完成注入，直接从全局获得即可(这里的_p属于占位符) 网易的同事在使用中有疑问可以私泡我(杭州研究院|前端技术部|郑海波) Requirejs 如果需要基于老家伙requirejs来管理模板，开发者可以有两种选择。 requirejs-text直接加载模板字符串 安装: bower install requirejs-text 配置 require.config({ paths : { \"text\": '../bower_components/requirejs-regular/rgl', \"regularjs\": '../bower_components/regularjs/dist/regular', \"restate\": '../restate', \"stateman\": '../bower_components/stateman/stateman' } }); 使用 require(['text!foo.html', 'regularjs'], function(tpl, Regular){ var Foo = Regular.extend({ name: 'foo', template: tpl }) return Foo; }); requirejs-regular加载和预处理模板 与requirejs-text插件的text!不同，这个插件配置的前缀是rgl!. 配置 require.config({ ... paths : { \"rgl\": 'path/to/requirejs-regular/rgl', //... } ... }); 使用 require(['rgl!foo.html', 'regularjs'], function( tpl, Regular){ var Foo = Regular.extend({ name: 'foo', template: tpl }) return Foo; }); 点击https://github.com/regularjs/requirejs-regular 查看更多详细说明 你不用上述模块方案？ 如果以上几种模块体系都是不是你的选择，也许你需要自己实现一个处理插件了，regularjs本身以打包了umd模块，可以同时在node和browser环境被使用， 使用 Regular.parse来处理你的模板字符串吧， const Regular = require(\"regularjs\"); const AST = Regular.parse(\"{title}\", { BEGIN: '{', END: '}' }) 具体可以参考基于webpack的rgl-loader的实现方案，寥寥几行代码。 当然如果你不需要预解析，直接传入字符串给Regular即可。 总结 上面的解决方案真是让人眼花缭乱，但共性也很明显: 所有可以加载纯文本的方式都可以用来加载Regular的模板。比如requirejs-text等插件，而加载文本几乎是模块化工具的标配了 如果你需要预先解析，可以使用Regular.parse封装出对应的工具。已经预先提供了requirejs, webpack, browserify 和 NEJ的相关工具。 如果需要类似Vue的单文件组件的写法，请参考单文件组件; "},"topic/ssr.html":{"url":"topic/ssr.html","title":"服务端渲染","keywords":"","body":"服务端渲染 流程图 Regular服务端渲染的基本流程如下 任务拆解 后端 根据组件输出首屏字符串 注入首屏数据到html中 前端 根据组件以及后端注入的首屏数据激活DOM，完成数据绑定和事件、指令等初始化 本文依赖 koa@v2: 用于创建简单的render server webpack@v4: 用于打包标准模块到前台使用 "},"topic/mpregular.html":{"url":"topic/mpregular.html","title":"微信小程序","keywords":"","body":"Regular 在微信小程序中的使用 随着最近一段时间微信小程序的大火，很多公司开始重视起了微信小程序上面的开发投入，甚至出现了很多类似小程序的平台，比如快应用、百度小程序、支付宝小程序等等 （注：下文提到的小程序皆指微信小程序） 理论基础 为什么 Regular 代码可以跑在小程序平台上？ 让我们先来看下微信小程序的整体架构 +--------------+ +---------------+ | View | | App Service | +----^---+-----+ +-----^---------+ | | | | data | | event event | | data | | | | +----+---v----------------+---v-----+ | JSBridge | +-----------------------------------+ View 对应视图层，App Service 对应我们的逻辑层 View 和 AppService 分别跑在两个线程中，通过 JSBridge 进行数据和事件的通信 实现思路 举个例子（伪代码）： Hello {{ __holders[ 'holder-id' ] }} const Component = Regular.extend( { config() { this.data.name = 'world' }, onClick() { console.log( 'clicked' ) } } ) const vm = new Component() 数据填充 只要通过一定规则拿到 holder-id 标识，就可以将 name 填充到模板的对应位置 事件处理 当 tap 触发时，会先执行 proxyEvent，mpregular 会在 proxyEvent 中通过 component-id 找到对应的 vm（ Regular 实例 ），再通过 event-id 找到真正的事件处理函数 onClick，然后执行 为什么设计 holders，而不传递真正的数据呢？ 我们先来看下 holders 是长什么样子的 { \"0\": ..., \"1\": ..., \"2-0\": ..., \"2-1\": ... } 是一种扁平的结构 虽然这么看 holders 感觉平平无奇，但这其实是 mpregular 中最重要的一个设计 全量的复杂表达式支持 借助 holders，我们实现了 Regular 复杂表达式的全量支持。由于逻辑层提前将所有数据计算并剥离出来，放到了一个扁平的数据结构中，所以我们不再需要 小程序视图层 提供这些复杂表达式特性的支持，完全摆脱了小程序本身的模板语法限制，现在的 View 只会被用来做纯粹的渲染 更高效的视图渲染 根据我们的实践，当调用小程序的 setData 时，如果 View 层接收的数据量过大，会导致渲染时的明显卡顿，原因可能是 View 层 diff 的数据量过大导致，在传递数据过程中有一个大列表带了很多冗余的数据过去，而这点通过警告开发者不要这么做，是很难保证的，后端经常会传输一些冗余字段到前端，比如一个数组中真正用于渲染的其实只是部分字段，如果每次都是人工代码干预的方式，过滤模板真正用到的字段，代码将会很难维护，针对这块，mpregular 内部会在 setData 前把用于模板渲染的数据全部抽离到 holders 上，每个数据坑位都能通过某个 id 拿到自己数据，View 的 diff 也只需要在一层扁平结构上进行，可以保证更高效的更新和更好的渲染表现，在框架层面解决了这个问题，用食堂大叔的话说就是吃多少拿多少 总结 通过静态分析 Regular 模板，提前将 数据坑位查找规则 和 事件处理函数查找规则 在构建阶段生成到 wxml 中，到了运行时阶段，小程序的视图层和逻辑层就可以无缝衔接起来 和业界框架的对比 特性 小程序 mpvue mpregular 模板语法规范 原生小程序 Vue 模板语法 Regular 模板语法 组件化支持 小程序组件规范 Vue 组件 Regular 组件 computed 计算属性 x o o model 双向绑定 x o o slot 插槽 x x o filter 过滤器 x x o html 富文本 x x o 复杂表达式插值 x x o 小程序分包 o x o 目前 mpvue 的 slot 支持还存在一定问题 上述表格的结果统计于 2018-8-17，如果数据过时，欢迎在 guide 仓库的 issue 中指出 感谢 mpvue 的实现思路给了 mpregular 很多的灵感，在此表示诚挚的感谢！ "},"topic/performance.html":{"url":"topic/performance.html","title":"性能指引","keywords":"","body":"Regular 性能优化的几点建议 本文旨在用 20% 的精力解决使用Regular过程中 80% 的性能问题. 这里大部分是关于脏检查的性能优化，不了解的可以先看下《Regular脏检查介绍》 首先，我们可以用一个简化后的公式来描述Regular的单次脏检查的复杂度 N·logN · M · T 其中 N : 代表组件深度 M : 代表组件平均监听器数量 T : 代表单个Watcher的检查时间 这样问题就落在了如何降低这三个因子了 降低N —— 组件层级 这层是收益最高的方案，因为影响因子是 N·logN. 以上图为例，叶子节点进行$update()时，会首先找到DigestRoot （默认情况下，即顶层使用 new 创建的组件），再层层向下进行组件的$digest()检查，在目前组件抽象较细致的开发习惯下，很容易产生10多层的组件深度，适当控制下digest深度可以得到可观的性能提升。 注 : 这个digest flow设计是为了避免产生网状更新链 方案1. 使用isolate 控制digest深度 第一个方式即使用isolate属性控制组件的数据流向，如 这样,在第一次初始化后，b组件就不再与a组件有任何数据绑定关系 如图所示，b组件此时就会成为g组件的实际DigestRoot。b组件内部的$update不会再会冒泡到外层 但这种方式同时让a的数据变更无法传达到b组件极其内部，如下图所示 如果需要实现a->b的单向传导，可以设置isolate=1 isolate = 1 实际就形成了组件的单向数据流 方案2. 合理抽象组件 除了通过isolate手动控制更新树的深度之外，我们直接减小组件深度当然也可以。 但这似乎与React等框架推崇的方式相悖，其实不然。 过度抽象的组件，除了引入使用负担和增加组件层级外，无法带来直观的收益。 抽象记得要基于复用的前提，没有复用前提的组件抽象，除了让你的文件夹变得更复杂外，毫无益处。 当然它可以给你带来好看的组件结构图 :) 降低M: 平均监听者数量 在Dirty-Check Loop中，在每个组件节点上都会经历$digest阶段: 遍历监听者数组，检查数据是否发生变更。 方案1. 升级到v0.5.2版本以上 首先将上面的公式再简化,并拓展到 一轮完整的脏检查Dirty-Check Loop ，可以用下面的公式来表示 ` K·P·T` 其中 K: 脏检查稳定性检测轮数 (1~30次不等，30次仍不稳定将抛出错误) P:￼digest影响到的所有监听器 T: 单个监听器的消耗时间 在Github: 0.5.2版本，有一个优化就是讲监听器分为了 稳定监听器（stable) 和 不稳定监听器(unstable) 不稳定的监听器即具有Side Effect，比如 this.$watch('firstName', (firstName)=>{ this.data.nickname = firstName + '先生' }) 当firstName改变时，nickname也会随之改变，所以为了确保不出错，框架会检测多轮直到这类监听表达式不再变化 稳定的监听器就是一些没有Side Effect的监听比如大部分内置的监听(文本插值、r-html、属性插值等), 这类监听处理逻辑只有读操作，而没有写操作。其实只需要检测一次即可 这样公式就修改为了 ` K·P1·T + P2·T` 其中 P1+P2 = P , P2 为Stable监听器， P1为非稳定。不要小看这个优化，由于内部监听器中, P2的比例很高(超过80%)所以在K>1的情况下，可以带来比较大的提升。 除此之外，你同时也可以自己主动来标记哪个监听器是属于stable this.$watch('title', (title)=>{ this.$refs.top.innerText = title }, {stable: true}) 2. 使用一次绑定表达式@(expression) 除非明确了不再对某个监听感兴趣，通过 一次绑定表达式 来提升性能其实并不是特别关键，但如果这个表达式正好在一个list循环中，那控制的收益会比较大，比如 {#list list as item by item_index} {/list} 如果这个列表有100项，那可以直接减少100个对item.list绑定(何况大部分情况都不止一个属性传入)， 属于操作少收益大。 降低T: 单个监听器的平均消耗时间 其实每个表达式比如user.firstName + '-' + user.lastName 需要判断变化的开销各不相同，我们只需要针对高开销的监听器进行控制即可达到效果。 1. 尽可能带上list语句的by描述 list是最容易产生性能瓶颈的部分，下面做下简单说明 默认情况下，Regular使用的莱文斯坦编辑距离(Levenshtein Distance), 别被吓到了，实际上wiki百科等资源上都有完成的伪代码描述, 是个简单的常用算法。 它的优点是，不需额外标记，就可以找到尽可能少的步骤从一个字符串过渡到另一个(但并不保证相同值一定被保留), 数组同理. 这样映射到框架内部，就可以以尽可能少的步骤来变更DOM了,相信大家都知道DOM开销很大了。 但是它的时间复杂度是O(n^2) ，在大列表下会带来显著的性能开销, 甚至完全超过DOM更新的开销。 所以在Regular v0.3的某个版本引入了by的用法, 例如 {#list items as item by item_index} {item.name} {/list} 顾名思义，新旧列表按顺序其item_index是不会变化的，即0,1,2... . 所以列表更新时，不会尝试去销毁重建，而是直接更新内部的值. 这种更新方式，内部的diff复杂度是 O(n), 属于极大的优化了性能.而且在DOM更新上比LS算法模式更轻量 这样用by item_index其实也带来一个问题，就是虽然循环对应的值改变了，但内部组件是不会重建的，即config、init不会被触发。 理论上 by 关键词之后可以接任意表达式，但是在之前版本是不生效的 (详情看#90 regularJS的track by没起作用) . 这个问题在最新版本已经被修复, 即你可以更精确的控制，是否要复用某一个项对应结构(内部组件是不会重建的，即config、init不会被触发) {#list items as item by item.id} {item.name} {/list} 举个例子，只要item.id ===0的项还在，那对应的DOM结构就确保不会被回收，只会进行更新操作. 这里的时间复杂度也是O(n), 但实际开销会比by item_index高不少。 2. 升级到v0.5.2减少销毁时间 在之前的版本, Regular的模板内容在销毁时，内部会进行大量的splice操作导致了性能问题，在0.5.2版本进行优化，整体销毁时间有了 数倍的提升 总结 从操作难易度和关键度上，主要是以下建议 升级到Regular最新版本(也方便你使用最新的SSR、跨组件通信等特性)，至少也是v0.5.2来整体提高性能(这个版本还做了不少别的性能优化) list记得使用by语句，特别是by item_index (item_index取决于你的命名) 组件通过isolate来控制digest深度 "},"topic/communication.html":{"url":"topic/communication.html","title":"️\b跨组件通信","keywords":"","body":"背景 在组件化不断深入的大环境下，无论使用哪种 MDV 框架都最终会遇到一个头疼的问题，就是「跨组件通信」。 下图是个简单的例子（ 为了方便起见，我把所有组件的模板都放在了一张图中进行描述 ） 这里包含「事件通信」和「数据通信」两个维度。 事件传递 为了将 click 事件 从 传递到最外层组件，需要依次通过 和 等可能本不关心这个事件的组件（即便例子里已经使用了简化语法） 数据传递 为了从 传递 title 这个 prop 到 , 需要层层跨越 、 这些本不需要关心 title属性 的组件。 以上处理方式除了带来性能上的损耗之外，更麻烦的就是造成了可维护性的急速下降。 显而易见的事件通信解决方案 最直接的做法就是引入一个「中介者」，简而言之就是一个全局的「跳板」，下面就是一个事件中介者的例子 mediator.js const Regular = require('regularjs'); const emitter = new Regular; // 每个Regular组件实例都是一个事件发射器 module.exports = { broadcast: emiter.$emit.bind(emiter), subscribe: emiter.$on.bind(emiter) } Top.js const { broadcast, subscribe } = require('./mediator') const Regular = require('regularjs'); const Top = Regular.extend({ name: 'Top', init(){ subscribe('check', ev =>{ // 通过emitter广播事件 }) } }) LeafNode.js const { broadcast, subscribe } = require('path/to/mediator') const Regular = require('regularjs'); const LeafNode = Regular.extend({ template: ``, name: 'LeafNode', onClick(){ broadcast( 'check', { type: 'leafnode' } ) } }) mediator 作为一个全局单例被 LeafNode 和 Top 直接引用，通过它实现了通信. 更复杂的兄弟节点之间的通信当然也可以这样来解决。 显而易见的解决方案引出的另一个显而易见的问题 上述引入全局中介者的最大问题就是，所有相关组件都在 定义时 引入了对emitter的 全局耦合， 这将导致组件无法被跨工程复用。 一种合理的解决方案就是将对emitter的耦合, 延迟到实例化阶段。 在Regular之前的版本里，很多朋友会通过this.$parent或this.$outer等可控性很差的方式来实现，在v0.6有了一种更好的方式。 modifyBodyComponent 新的生命周期 Regular 在 v0.6 版本引入了一个新的生命周期 modifyBodyComponent ，可以用它来劫持组件包裹的所有内部组件的初始化过程。 让我们用一个简单的例子来说明下modifyBodyComponent的具体使用，以及实现emitter的动态注入 Broadcastor.js const Regular = require('regularjs'); const Broadcastor = Regular.extend({ name: 'Broadcastor', config( data ){ const emitter = data.emitter; this._broadcast = emitter.$emit.bind(emitter), this._subscribe = emitter.$on.bind(emitter) }, modifyBodyComponent( component, next ){ component.$broadcast = this._broadcast; component.$subscribe = this._subscribe; next(component) // 交给外层的包装器 } }) Top.js // const { broadcast, subscribe } = require('./mediator') const Regular = require('regularjs'); const Top = Regular.extend({ name: 'Top', template: '略...', init(){ this.$subscribe('check', ev =>{ // 通过emitter广播事件 }) } }) LeafNode.js // const { broadcast, subscribe } = require('path/to/mediator') const Regular = require('regularjs'); const LeafNode = Regular.extend({ template: ``, name: 'LeafNode', onClick(){ this.$broadcast( 'check', { type: 'leafnode' } ) } }) main.js (入口) new Regular({ template:` `, data: { emitter: new Regular } }) 这样所有的组件都不再直接依赖全局的 emitter，而是在入口(main.js) 动态传入了一个emitter。 生命周期 需要注意的是modifyBodyComponent 会在 component本身compile之后运行, 但在init之前运行。以上面的例子为例, 完整生命周期如下. Broadcastor.config -> Broadcastor.compile - Top.config -> Top.compile - LeafNode.config -> LeafNode.compile - Broadcastor.modifyBodyComponent(LeafNode) - LeafNode.init - Broadcastor.modifyBodyComponent(Top) - Top.init - Broadcastor.init "},"topic/todomvc.html":{"url":"topic/todomvc.html","title":"50行代码的todomvc","keywords":"","body":"前言 现在市面上充斥了越来越多的javascript框架，给开发者的技术选型带来极大的选择成本，todomvc在这个环境下应运而生。 由于todomvc有一个完整的实现定义，它复杂度适中，大概就是平时开发的一个组件的功能复杂度，开发者可以轻松对各个框架的代码做对比，同时由于功能一致，也可以进行各框架之间的性能对比(当然这个测试案例其实并没有很大的实际意义)。 接下来这篇指南会一步步的带大家使用Regularjs按照规范实现一个完整的todomvc的app。 第一步: 静态页面 第一步，我们需要一个完整的静态页面作为后续逻辑的基础，这里我们不再详细介绍如何实现这个页面，直接从todomvc的官网copy一份静态页面下来。 TODOMVC Mark all as complete sleep work 1 item left All Active Completed Clear completed (1) Double-click to edit a todo Created by @leeluolee Part of TodoMVC 你可以直接保存成index.html来查看效果，也直接在codepen中查看 第二步: 视图(模板)与数据model分离 按以往的经验，我们应该使用jQuery等框架来一个个绑定节点处理业务逻辑了。这样会带来很多的问题，一旦你去绑定了大量的dom事件和进行了过多的dom操作，往往会带你进入难以维护的深渊，我们可以使用模板来强制将model(模型)与视图(view)分开。 所以这一步，我们什么都不做，仅仅只是将上面的静态页面转由regularjs模板生成。 TODOMVC Mark all as complete sleep work 1 item left All Active Completed Clear completed (1) 然后我们利用regularjs来compile这个模板 var TodoMVC = Regular.extend({ template: \"#todomvc\" }) var app = new TodoMVC({ data: {} }).$inject('#todoapp'); 在codepen中查看结果 其中Regular.extend用于定义一个组件，最基本的情况就是指定一个模板（template字段），而new TodoMVC相当于是compile这个组件，一般我们会在这里传入data模型，我们同时将compile后的组件插入到节点#todoapp中。 事实上大家都发现了，这里我们完全没有做额外的逻辑，但是这是将view与model分开的关键一步。 DEMO2 第三步: 使用#list指令来处理列表 我们发现，很明显的model可以抽象成一份todos的数组，所以我们的第一步是使用list来处理列表逻辑（这里我们省略了其余部分的模板，只列出了li部分的逻辑） .... {#list todos as todo} { todo.description } {/list} ..... list规则用于处理循环逻辑，完整描述可以查看Regularjs指南的list部分。这里我们也应用到了最基础的插值({}) 我们传入一个todos的假数据 var todos = [ {completed: true, description: \"sleep\" }, {completed: false, description: \"work\" } ] var app = new TodoMVC({ data: {todos: todos} }).$inject(\"#todoapp\") DEMO3 可以看到我们同时利用directive处理了一些业务逻辑 r-class： 属于对象表达式，每当值为真，添加对应的键作为class r-model: 使表单项与某字段形成双向绑定 on-xx: 绑定事件 regularjs的parse是基于字符串的，它输出包含完整信息的ast给基于dom的compiler使用，这样其实输出的内容是不会包含一些常规dom-based模板的placeholder信息的（比如angular的ng-xx）。 到这一步，其实可以发现，我们可以处理一部分业务逻辑了，比如 双击编辑 回车完成编辑 标记完成 删除指定的todo项(利用todo_index下标，它的命名取决于你定义的列表项的名称加_index) regularjs的数据驱动是基于代码脏检查的（与angular一致），所以你可以直接操作裸数据来完成状态变更。 第四步： 完善我们的组件业务逻辑 目前，除了中间列表部分的view，其它部分的数据都没有完成数据联动。我们遗留的业务逻辑有: 点击下方的All Active Completed面板要完成todos面板的切换来分别显示所有、未完成、完成的todo列表 上面的input可以进行新建todo 切换左上角的checkbox可以进行标记全部和取消编辑全部的操作 点击右下角的clearComplete 应该可以删除所有完成的列表项 一个组件的业务逻辑（对于一个mvvm模式的组件来讲，业务逻辑应该是纯数据操作）应该是在定义时就进行确定。我们在extend时定义这些业务。 var TodoMVC = Regular.extend({ template: '#todomvc', // get the list; getList: function(filter){ if(!filter || filter === 'all') return this.data.todos; else return this.data.todos.filter(function(item){ return filter === 'completed'? item.completed : !item.completed; }); }, // toggle all todo's completed state toggleAll: function(sign){ this.data.todos.forEach(function(item){ return item.completed = !sign; }); }, // clear all compleled clearCompleted: function(){ this.data.todos = this.data.todos.filter(function(item){ return !item.completed }); }, // create a new todo newTodo: function(editTodo){ var data = this.data; data.todos.unshift({description: editTodo}); data.editTodo = \"\"; } }) 至此，TodoMVC实现了以下4个对应逻辑 getList(sign): 用于获得不同的列表 newTodo(editTodo): 用于创建新的todo toggleAll(sign): 用于全部标注完成，和全部取消 clearCompleted(): 用于删除所有完成的todo 大家可以发现，所有的操作都是基于裸数据的业务逻辑，没有添加任何dom操作。 但是如何使用这些函数定义呢？ 很简单，首先extend的函数是定义在组件原型上的，其次模板中的this是指向组件实例，即： 我们可以通过this.xx()等方式在模板中调用这些逻辑定义。完整模板我们修改为 regular-todo Mark all as complete {#list this.getList(filter) as todo} { todo.description } {/list} { this.getList('active').length } { this.getList('active').length === 1 ? 'item' : 'items' } left All Active Completed Clear completed ({ this.getList('completed').length }) DEMO4 第五步： 使用计算属性来简化我们的表达式 这里我们发现，使用了大量的相似的表达式在我们的模板里，比如为了处理全选与反选，我们引入有如此肮脏的模板代码 如果我们引入计算属性（computed-property）就可以简化此表达式 我们可以extend时进行计算属性的定义 var TodoMVC = Regular.extend({ template: \"#todomvc\", computed: { completedLength: \"this.getList('completed').length\", activeLength: \"this.getList('active').length\", allCompleted: { get: function(data){ return data.todos.length === this.getList('completed').length }, set: function(sign,data){ data.todos.forEach(function(item){ item.completed = sign; }) } } } //....other methods... }) 在这里我们定义三个计算属性 completedLength: 代表完成的todo的length activeLength： 代表未完成的Length，这里可以看到1和2属性，我们都直接传入了一个字符串表达式，因为这里只需要处理读操作，即只是表达式的一种简写替代 allCompleted: 标记是否全部完成，为真则将左上的checkbox打钩。需要注意的是这里还设置了setter函数，用于处理allCompelted的写操作，这里我们做的是，将所有todo标记完成或未完成 修改后的模板如下 regular-todo Mark all as complete {#list this.getList(filter) as todo} { todo.description } {/list} { activeLength } { activeLength === 1 ? 'item' : 'items' } left All Active Completed Clear completed ({ completedLength }) 至此，我们利用大约40行模板+50行代码实现了todomv。并且完全没有掺入dom操作，完全是按照以前使用模板的思维。 第六步: 使用if/else来控制区域的创建与回收 按照todomvc的规范定义，我们遗漏了以下两个逻辑 需要在没有todos的情况隐藏显示部分， 并且在没有可清楚todo的情况下，隐藏 我们可以利用两种方式来实现 {#if}: 这种情况会将区域完全回收，并移除所有绑定，这是一种语法元素。 r-hide: 你也可以使用指令来切换节点的可见性，这只是一种指令增强。 1相较于2，最大的不同是完整回收，并且可以作用于任意的块: 比如多个并列节点。而2只能以节点为单位（即类似与angular的ng-show） 这里我们采用if来完成我们的需求。修改后的模板如下 {#if !!todos.length} ...ignored for short... ...ignored for short... {#if completedLength} Clear completed ({ completedLength }) {/if} {/if} DEMO5 第七步: 抽离子组件 到目前为止，除了路由部分，我们已经完整实现了整个组件（由于regularjs定义为一个类库，所以不提供框架级的路由服务，大家可以通过类似stateman等第三方库来实现路由）。 但是所有的view都写在了一个模板中，这个不利用后续的重构。我们可以通过子组件来提取一些独立的逻辑，在这个例子里，一个todo项目显然可以独立出来成为一个组件 { todo.description } 注意这里的on-click='remove' 代表点击后抛出自定义事件remove，你可以捕获这个事件来处理删除操作（因为我们无法获得todos数据了） 对应的组件定义 var Todo = Regular.extend({ data: {todo: {}}, name: \"todo\", template: \"#todo\" }); 注意name参数代表，这个组件可以通过的方式插入其它模板中。 重构之前的list部分 {#list this.getList(filter) as todo} {/list} 这里我们直接通过on-remove来捕获子组件抛出的remove事件。 很明显的看到，利用子组件和持续重构可以帮助我们维护越来越复杂的组件关系。 DEMO6 结尾 至此，我们在仅40行模板+50行js代码(纯数据的业务操作)实现了一个功能基本完整的组件，并且没有引入任何dom操作。 "},"reference/":{"url":"reference/","title":"索引手册","keywords":"","body":""},"reference/api.html":{"url":"reference/api.html","title":"API","keywords":"","body":"API Reference 命名约定 Component 此接口同时属于Regular及其子类. Regular　此接口只属于Regular本身 component: 代表Regular及其子类的实例 静态接口 Component.extend( options ) 创建一个继承自Component的组件，参数 options 中的所有属性都会成为 原型属性. Usage: const Component = Regular.extend({ template: ` {count} 点击加a `, tick: function(posfix) { this.data.count += posfix; } }) Arguments Param Type Detail options Object 组件定义和配置,见 options Return Component 注意 extend 是原型继承的一个语法糖，options是实例共享的 Component.implement(options) 扩展Component的原型属性与方法。 options 与Component.extend一致.　 Arguments Param Type Detail options Object 组件定义和配置,见 options Return Component 小技巧: 通过 implement 与 extend 扩展的方法，都可以通过this.supr(arg1, arg2..)调用父类同名函数 \"Regular的类式继承体系来源于著名的ded/klass.\" Example Component.extend({ init: function(){ this.supr() // call the super init } }).implement({ hello: function( msg ){ this.supr( msg ) // call the super hello } }) new Component(options) Example var component = new Component({ // ...other options data: { username: \"leeluolee\" } }) component.$inject('#container'); Arguments Param Type Detail options Object 组件定义和配置,见 options Return Component的实例: 查看实例接口 通过实例化传入的 options 将成为实例属性, 意味它将覆盖 extend 与 implement 的定义.并且方法中无法使用 this.supr() Component.directive(name, definition) 定义指令 Arguments param type detail name String 指令名 definition.link Function[required] 链接函数,指令编译时会被调用 definition.update Function[optional] 更新函数,指令绑定的表达式变更时会被调用 definition.params Array[optional] 指令参数,指定指令参数列表 如果 definition 是一个 Function，则视为成为link函数 definition.link(elem, value) elem 绑定的元素节点 value 属性值(可能是字符串或是一个[Expression]; this 这里的this指向component组件本身 definition.update(elem, value) elem 绑定的元素节点 value 属性值(可能是字符串或是一个[Expression]; this 这里的this指向component组件本身 definition.params Example (source code of builtin r-html ) Regular.directive('r-html', function(elem, value){ this.$watch(value, function(newValue){ elem.innerHTML = newValue }) }) 这里由于$watch同时接受字符串或者Expression, 所以我们可以在模板里传字符串或插值, 最终r-html的效果是一样的 如果必要你也可以在函数返回一个destroy函数做指令的销毁工作(比如绑定了节点事件). 需要注意的是, regular中watch数据是不需要进行销毁的, regular会自动清理对应的数据绑定 Example Regular.directive('some-directive', function(elem, value){ return function destroy(){ ... destroy logic } }) Component.filter regularjs 当然也支持普遍存在于模板中的过滤器，过滤器支持链式的多重调用. regularjs也支持双向过滤, 来帮助你解决双向数据流的需求 Usage Component.filter(name, factory) Syntax {Expression|filter1: args.. | filter2: args...} Arguments param type detail name string 过滤器名称 factory function object 创建新的自定义过滤器 factory factory.get(origin, args...) [Function]: 数据从终点到源的处理函数. factory.set(dest, args...) [Function]: 从最终结果反推到源头的处理函数. . 如果传入的factory是函数类型，则自动成为factory.get Example1 > 一个简单的日期格式化过滤器 // simplest date format var filter = function(){ function fix(str){ str = \"\" + (str || \"\"); return str.length 然后在模板中使用 {time| format: 'yyyy-MM-dd HH:mm'} 输出 2014-12-31 12:30 双向过滤器 双向过滤器主要是帮助我们实现数据的对流, 对任意数据读或写操作时可以进行过滤操作, 与计算属性不同的是，双向过滤器定义是不与具体的数据进行绑定,它是一种可复用的抽象. 双向过滤器如其名，经常会用在双向绑定上， 由于这个特性， r-model 得以与一个数组类型实现双向绑定。 当然你也可以使用它在其它可能有“数据回流”场合，比如内嵌组件 take {[1,2,3]|join: '-'} for example 过滤器定义 Regular.filter('join', { //[\"1\",\"2\",\"3\"] - > '1-2-3' get: function(origin, split ){ return origin.join( split || \"-\" ); }, // **Important ** // \"1\"-\"2\"-\"3\" - > [\"1\",\"2\",\"3\"] set: function(dest, split ){ return dest.split( split || \"-\" ); } }) {array|json} 【 DEMO : two-way filter】 内建过滤器 json 这是一个双向过滤器 example var component = new Regular({ template: \"{user|json}\" }) component.$update(\"user|json\", \"{'name': 'leeluolee', 'age': 10}\") //console.log(user) --> {'user':'leeluolee', 'age': 10} Only Browser that support JSON API can get the json filter last 获得数组最后一个元素, 这是一个单向过滤器 {[1,2,3]|last} ===> 3 Component.event Usage Component.event(name, factory) 设置自定义dom事件 Argument Param Type Detail name String the custom event name factory Function Factory function for creating event type Component.animation 自定义一个动画command. animation接口完全是为r-animation指令服务的. 查看 指南: animation 了解更多 Usage Component.animation(name, factory) Arguments Param Type Detail name String the custom animation name factory Function Factory function for creating command Example Component.component 注册一个组件，使其可以被,　这里类似与在options中声明name Usage Component.component(name, factory) Arguments Param Type Detail name String the name used to insert Component in template factory Component A Component to be register Example > var Pager = Regular.extend({ // other options }) Component.component('pager', Pager) // you can use pager as nested component Component2 = Component.extend({ template: \"\" }) Component.use Usage Component.use(factory) 著名的angular中模块化的解决方案是angular.module()和依赖注入, 一个模块可以有factory可以有filter可以有directive等等. 在regular中不可能照搬这种方式, 这是因为 regular中没有$rootScope.$digest()这种全局性的解药无脑的促使所有绑定进入数据检查阶段，regular组件的生命周期都是独立的, 这就决定了必须让扩展建立与组件的关系. 比如angular的$timeout之类的实现只需在定时器完成后$rootScope.$digest()即可进入全局的数据检查, 而regular中timeout之后必须调用组件的$update()才进入组件本身的数据检查阶段,即需建立与组件的关系. 模块插件应该是与组件无关的, 绑定只应该在被使用时发生, 这样才是可复用的模块插件. 所以一个典型的插件的写法应该是这样的 function FooPlugin(Componenet){ Component.implement()// implement method .filter() // define filter .directive() // define directive .event() // define custom event } var YourComponent = Regular.extend(); FooPlugin(YourComponent); // lazy bind FooPlugin(Regular); // lazy bind to globals 为了更统一, 所有Component都有一个use函数来统一'使用'插件, 如上例可以写成 YourComponent.use(FooPlugin); // global Regular.use(FooPlugin); options new Component，Component.extend, Component.implement　都接受同一种 options 参数 没有提及的配置项都会自动成为Component的原型属性( 或实例属性 ) template type: String | AST 模板字符串需要遵循模板语法，模板只会在首次实例化时被编译一次 你可以选择在构建时通过 Regular.parse 将模板先处理成 AST 。 name 注册组件到父组件的命名空间内，使其可以被声明式调用。 注意通过name注册，是全局的 const Component = SuperComponent.extend({ //other options name: 'foo1' }) const Component2 = SuperComponent.extend({ template: \"\" }) 也可使用Component.component 注册,　上例实际上等同于 const Component = SuperComponent.extend({}); Regular.component('foo1', Component) events type: Object 批量定义绑定事件，__这个在需要绑定一些内置事件时格外有用。 Regular.extend({ events: { \"$init\": function(){ // same in component.init }, \"$destroy\": function(){ // same in component.destroy } } }) data type: Object ⚠️不要在 extend 或 implement 时定义data属性 !!! ，这会导致所有实例共享数据。 永远只在 new Component 或 config 中定义初始化函数 computed Type: Object 计算属性定义为键值对 key: 表达式名 value: 表达式定义 Example comuted: { title: } 表达式定义支持几种类型 生命周期钩子 options 中还可以定义如下生命周期钩子 config( data ) type: Function 在模板编译 之前 被调用，config一般是用来初始化参数，它接受的 data 即你在new Component() 时传入的 data属性。 init() type: Function 会在模板编译 之后( 即DOM结构已产生 )被调用. 你可以在这里处理一些与DOM相关的逻辑　 destory() type: Function 如果你需要有额外的回收逻辑, 你可以重写destroy方法 记得调用this.supr()来运行默认的回收逻辑 !!!!, 否则会回收失败 var Component = Regular.extend({ //..... destroy: function(){ this.supr(); // call the super destroy ...other logic } }) var component = new Component(); component.destory(); modifyBodyComponent( component, next ) 实例接口 component即代表组件实例, 注意这些公有都有$前缀 意味不建议进行重写 component.$inject 插入组件到指定位置 Usage component.$inject(element[, direction]) Arguments Param Type Detail element Node false 被插入节点，如果传入false则代表将此组件从dom中移除 direction(optional default:'bottom') String 组件的位置插入目标的位置.　可以是 'top', 'bottom', 'after', or 'before'. Example > 假设你已经有这样一个组件 var component = new Component({ template: \"{title}\", data: { title : \"Example\" } }) var div = document.getElementById(\"#div\"); 和一段html片段 compnent.$inject( div ) or component.$inject( div, 'bottom' ) resulting html Example compnent.$inject( div, 'top' ) resulting html Example compnent.$inject( div, 'after' ) resulting html Example or component.$inject( div, 'before' ) resulting html Example component.$inject( false )(假设我们已经调用了以上方法插入了本组件) 完全从原插入位置移除它(但是没有销毁，你仍然可以再次$inject它) resulting html Tips 你通过多次调用$inject 将组件有一个位置移动到另外一个位置 component.$watch 注册一个监听回调，一旦绑定的表达式的值发生改变，它将会被调用 Usage component.$watch(expression, callback [, options]) Arguments Param Type Detail expression Expression 一旦表达式求值发生改变，回调会被触发 callback(newValue, oldValue) Function 回调接受两个参数. 1. newValue: 表达式的新值. 2.oldValue: 表达式的原值 Return watchid [Number]: 监听id,用于方法 $unwatch expression 会在每次脏检查时被调用，并比较之前的值 当值与上次求值发生变化的判断依据是严格不相等即!==.　一种例外就是当求值为数组时，Regularjs会使用莱文斯坦距离计算数组差异 component.$watch(\"user.name\", function(newValue, oldValue){ alert(\"user.name changed from \" + oldValue + \" to \" + newValue) ; }) component.$unwatch 利用watchid解绑一个数据监听,　一般来讲你很少会用到它，因为所有regularjs中的数据绑定会被自动回收，除非你想在模板回收之前清除某个绑定. Usage var component = new Regular(); component.$watch('b', function(b){ alert('b watcher 1'); }) var id = component.$watch('b', function(){ alert('b watcher 2'); }) component.$unwatch(id); component.$update('b', 100); // only alert 'watcher 1' component.$update component.$update is used to synchronize data and view 由于regularjs是基于脏检查，所以当不是由regularjs本身控制的操作(如事件、指令)引起的数据操作，可能需要你手动的去同步data与view的数据. $update方法即帮助将你的data同步到view层. Usage component.$update([expr] [, value]) 更新某个值，并强制进入digest阶段，即脏检查. Arguments expr(Optional) [Expression| Function | String] - expression可以有多种参数类型 String: 此字符串会先被Regular.expression处理为Expression Expression: 此expression需要有set函数, 查看Expression Object: 多重设值 value - 设置的值 Example > var component = new Regular({ template: \"{title}\", data: { title: \"REGULARJS\" } }); //=> log 'REGULARJS' , with no doubt console.log( component.$refs.h2.innerHTML ) component.data.title = \"LEELUOLEE\"; //=> also log 'REGULARJS', regularjs don't know the value is changed. console.log( component.$refs.h2.innerHTML ) // // force synchronizing data and view component.$update() //=> also 'REGULARJS'. synchronize now. console.log( component.$refs.h2.innerHTML ) // // trigger on-click event component.$refs.h2.click(); // should log leeluolee. // the Expression `title=title.toLowerCase()` is actived. // when listener is done, regularjs will enter digest phase console.log( component.$refs.h2.innerHTML ) // you may need check $refs first Beacuse you may need to set a complex Expression, $update also accept optional params to set the property easily, for Example // 1. simple component.$update(\"user.name\", 'leeluolee') // is equals to component.data.user.name = 'leeluolee' component.$update() // 2. multiple component.$update({ \"user.name\": \"leeluolee\", \"user.age\": 20 }) // is equlas to component.data.user.name = 'leeluolee' component.data.user.age = 20 component.$update() 你当然也可以使用更复杂的表达式，不过你必须保证你的表达式是可设值的, 不过由于会创建表达式，这显然是不高效的，作者强烈建议不怎么做，　除非你需要通过双向过滤器来设值. // JSON.parse the title first. component.$update('title|json', \"{'title': 1}\"); console.log(component.data.title) // => {title:1}; Warning: 无论传入什么参数，运行$update之后都会进行组件作用域内的dirty-check component.$get Usage component.$get(Expression|String) 获得一个Expression的值,类似于angular的$eval函数 Example > component.data.username = \"leeluolee\" component.data.job = \"developer\" component.$get('username + \":\" + job') // => leeluolee:developer Arguments Param Type Detail expression Expression String 表达式 component.$refs type: Object 在模板中，你可以使用ref属性来标记一个节点或组件.　在实例化后，你可以通过component.$refs 来获取你标记的节点 Example > component = new Regular({ template: \" \", init: function(){ this.$refs.input // -> the input tag this.$refs.pager // -> the pager component } }) The less reference the better component.$on Register an event handler fn. Usage component.$on(event, fn]) Arguments Param Type Detail eventName Object String 事件名 fn Function 监听器回调 如果你传入一个Object, 会成为一个多重事件绑定 Example > component.$on(\"hello\", fn1) // multiple component.$on({ notify: fn2, message: fn3 }) component.$off Usage component.$off([event] [,fn]) Arguments Param Type Detail eventName Object String 事件名 fn Function 监听器回调 如果同时传入 event和fn,　则移除指定event类型下的fn函数 只传入event, 移除所有event对应的监听器 什么都不传，移除所有 component.$emit 触发指定事件 Usage component.$emit(eventName [, args...]) Arguments Param Type Detail eventName Object String 事件名 args Function 剩余的参数都会作为参数传入到监听器 Example > var component = new Regular(); var clickhandler1 = function(arg1){ console.log('clickhandler1:' + arg1)} var clickhandler2 = function(arg1){ console.log('clickhandler2:' + arg1)} var clickhandler3 = function(arg1){ console.log('clickhandler3:' + arg1)} component.$on('hello', clickhandler1); component.$on('hello', clickhandler2); component.$on({ 'other': clickhandler3 }); component.$emit('hello', 1); // handler1 handler2 trigger component.$off('hello', clickhandler1) // hello: handler1 removed component.$emit('hello', 2); // handler1 handler2 trigger component.$off('hello') // all hello handler removed component.$off() // all component's handler removed component.$emit('other'); component.$mute 你可以使用$mute(true)让组件失效，使其不参与到脏检查中. 后续使用 $mute(false)　来重新激活一个被失效的组件,　激活的同时，会自动进行一次数据与ui同步. Usage component.$mute( isMute ) Argument Param Type Detail mute Boolean 是否disable这个组件(可以后续重启它) Example > var component = new Regular({ template: '{title}', data: { title: \"hello\" } }) //resulting html hello component.$mute(true) // disable it component.data.hello = 'title changed' component.$update(); // resulting html hello component.$bind 创建组件之间的双向绑定. 这已是一个不推荐的方法. 由于$bind过于灵活的双向绑定，极可能不当使用带来难以维护的对象间关系. 请使用事件通讯来处理组件之间的消息同步。 Usage component.$bind(component2, expr1[, expr2]) Arguments component2: 要绑定的组件 expr1 : 此参数有多种参数类型 Expression|String: 本组件要绑定的表达式 Object: 同时绑定多个表达式对 Array: 表达式列表,同时实现多个同名表达式(即只传入expr1) expr2 : 目标组件要绑定的表达式, 缺省为expr1 WARN 如果两个表达式都是setable的，可实现双向绑定，否则只能实现单向绑定 如果连个组件在bind时是不同步的，component2数据会先同步到component create binding between pager components. // insert var pager = new Pager( {data: {total: 100, current:20}} ).$inject('#bind1'); var pager2 = new Pager( {data: {total: 50, current:2}} ).$inject('#bind1'); var pager3 = new Pager({data: {total: 100, current:20} }).$inject('#bind2'); var pager4 = new Pager({data: {total: 50, current:2}}).$inject('#bind2'); var pager5 = new Pager({data: {total: 100, current:2}}).$inject('#bind3'); var pager6 = new Pager({data: {total: 50, current:20}}).$inject('#bind3'); // style 1 pager.$bind(pager2, ['current', 'total']); // style 2 pager3.$bind(pager4, 'current', 'current') pager3.$bind(pager4, 'total') // the same as pager3.$bind(pager4, 'total', 'total') // style 3 pager5.$bind(pager6, {current: \"current\", total: \"total\"}); // bind chain var pager = new Pager({data:{total: 1000, current:1}}).$inject('#bind_chain'); for(var i = 0; i Demo here you may want the source code of pager 其它 Regular.dom 由于内部实现需要，Regular实现了部分常用的跨浏览器的dom方法，如果只是简单的dom处理，你可以直接使用Regular.dom. Regular.dom.inject(element, refer, direction) component.$inject 依赖于此方法 Arguments Param Type Detail element Node false 要被插入的节点 refer Node false 参考节点 direction(optional default:'bottom') String 组件的位置插入目标的位置.　可以是 'top', 'bottom', 'after', or 'before'. Regular.dom.on(element, event, handle) 绑定节点事件,　下列事件对象中的属性已经被修正，你可以在IE6-8使用它们. 回调的this对象也修正为element本身. event.target event.which event.pageX event.pageY event.stopPropagation(); event.preventDefault(); Example > var dom = Regular.dom; dom.on(element, 'click', function(ev){ ev.preventDefault(); }) Regular.dom.off(node, event, handle) 移除一个事件监听器 Regular.dom.addClass(element, className) 添加节点className Regular.dom.delClass(element, className) 移除节点的某段className Regular.dom.hasClass(element, className) 判断节点是否拥有某个className dom.hasClass(element, 'class1') // => true Regular.dom.text(element[, value]) 根据浏览器和节点, 设置节点的textContent　或　innerText Regular.dom.html(element[, value]) 设置或获取节点的innerHTML值 Regular.dom.attr(element, name [ , value]) 设置或获取节点的指定属性 Regular.config 配置一些全局属性, 目前主要可以用来配置模板的自定义开关符号 Usage Regular.config( settings ) Arguments Param Type Detail settings.BEGIN String OPEN_TAG (default: '{') settings.END String END_TAG (default: '}') Example > 将默认符号{}修改为 {{}}. Regular.config({ BEGIN: \"{{\", END: \"}}\" }) Regular.parse Usage Regular.parse(templateString, setting) 解析模板字符串为AST, 基本上你不会使用此方法, 你可以使用此方法来预解析你得regularjs模板 Arguments Param Type Detail templateString String 要解析的模板字符串 settings.BEGIN String 开符号 (default: '{' settings.END String 关符号 (default: '}') settings.stringify Boolean 是否stringify 输出的AST (default: false) Usage Example > Regular.parse(\"{{page.title + page.desc}}\", { BEGIN: '{{', END: '}}' }) // output [ { \"type\": \"element\", \"tag\": \"h2\", \"attrs\": [], \"children\": [ { \"type\": \"expression\", \"body\": \"_d_['page']['title']+'-'+_d_['page']['desc']\", \"constant\": false, \"setbody\": false } ] } ] 服务端渲染 "},"reference/styleguide.html":{"url":"reference/styleguide.html","title":"风格指南","keywords":"","body":"风格指南 - styleguide 与类似文档一样，Regular 将风格指南设置为了多个优先级，分别是 必要的: 程序运行可能会出问题的，强制遵循 建议的: 不遵循程序可以运行，但会引起可维护性或性能的问题 谨慎使用的: 未来可能会废弃的使用方式，谨慎使用 必要的 禁止在extend中定义缺省data参数 {} 在 config 生命周期中处理默认参数，而不是的 extend 时定义 Bad Regular.extend({ data: { list: [1,2,3] } }) Good Regular.extend({ config( data ){ data.list = data.list || [1,2,3] } }) Very Good 更好的做法是一个一致的缺省参数逻辑, 比如使用util.extend(会默认添加未定义的值) const extend = Regular.util.extend; Regular.extend({ config( data ){ extend(data, { list: [ 1, 2, 3 ] }) } }) 未来 Regular 会提供统一的 default 书写方式 (会结合入参的检验机制共同设计)。 谨记 extend 是原型继承的语法糖，所以原型上的定义都是实例公用的 参考 组件:默认参数 自定义destroy 必须调用 this.supr() 由于一些历史原因，Regular有一个肮脏的设计：即destory既被定义为生命周期钩子方法，又是一个对外的public API。 为了确保组件回收的统一逻辑,请调用 this.supr() 来引入Regular.prototype.destory 中的回收逻辑 Bad const Component = Regular.extend({ destory(){ window.removeEventListener('scroll', this.onScroll) } }) Good const Component = Regular.extend({ destory(){ this.supr() window.removeEventListener('scroll', this.onScroll) } }) 建议的 大 list渲染尽量加入 by 条件 Good {#list items as item by item_index} {item.content} {/list} Bad {#list items as item} {item.content} {/list} 但并非所有场景都可以使用 track by 进行控制，请参考 list语句章节 参考 专题：性能优化的几个建议 组件命名 - 大写驼峰 Regular 本身并无强限制组件的命名方式。 建议以 大写驼峰 的方式进行组件命名，并且 类名和 name 统一 Bad const ConfirmModal = Regular.extend({ name: 'confirm-modal' }) Good const ConfirmModal = Regular.extend({ name: 'ConfirmModal', // 略 }) 谨慎使用的 不要用if语句去控制属性的增删 if语句其实可以使用在节点属性上，但已经不建议大家这么做 Bad Good 相关逻辑迁移到JS // Regular会自动转义类似required、readonly 等 Boolean 类属性 Regular.extend({ template: ` `, clickMe(){ // 在js中控制 if( !this.data.active ) return; } }) 理由 使用if语句去控制属性有几个风险 存在自定义指令未实现 destroy 函数的可能，进而导致 Bug 这种在模板里夹杂大量逻辑的写法会引起可维护性降低 未来可能会移除这个Feature 事件与双向绑定 Bad const Input2 = Regular.extend({ name: 'Input2', template: `` changeValue(ev){ this.data.value = ev.target.value; this.$emit('change'); // emit change event } }) new Regular({ template: ` `, handleValue(){ console.log(this.data.value) // 返回的仍然是上一个值 } }).$inject('body') 这里你会发现返回的仍然是上一个值 为什么? 因为触发事件的时候，并没有进入脏检查，外层的数据其实还未被同步。 Not So Bad const Input2 = Regular.extend({ name: 'Input2', template: `` changeValue(ev){ this.data.value = ev.target.value; setTimeout(()=>{ this.$emit('change'); //emit },0) } }) 当通过类似setTimeout将其延迟到脏检查之后的时机触发，此时的结果就如预期了。 Good @TODO: new feature required "},"reference/directive.html":{"url":"reference/directive.html","title":"✔内建指令","keywords":"","body":"内置指令 Regular 提供少量常用指令解决语法能力的不足, 你也尝试实现自己的指令 on-[eventName] 绑定事件。 Example on-click={expression} Arguments Param Type Detail expression Expression 每当指定事件触发，该表达式会被运行 $event 事件对象 请参考事件章节 事件系统完整指南请参考 入门:事件 章节 r-model r-model 实现与表单类DOM元素的 双向绑定, 所以对应的表达式应该是 setable 的 Syntax r-model={Expression} Example Type input、textarea: 绑定类型: String hahah input:checkbox: 绑定类型: Boolean 绑定[checked]属性，注意需要是 Check me out (value: {checked}) input:radio: 绑定类型: String 可以绑定多个input:radio元素 select: 绑定类型: String 绑定select的value值 Hangzhou Ningbo Guangzhou 双向绑定不总是 「银弹」，复杂的数据关系，你可以考虑使用value属性 + 表单事件监听的方式来解决 r-style r-style={Expression} 是 style样式绑定的增强指令 Exmaple new Regular({ template: ` left+10 left: {left}`, data: { left: 1 } }).inject(document.body) Arguments Param Type Details r-style expression Expression 求值结果应该是一个Object, 键是样式名，值是样式值 (注意Regular并不处理默认单位，请主动添加) ⚠️如果已经有 style 插值了，那r-style的将会被覆盖 例如 r-class 与r-style 类型， 不过 r-class作用于 class 属性 Example 上例中，如果page === 'home',则active会被添加到div节点的class属性中 Description Param Type Details r-class expression Expression 求值结果应该是一个Object, 键是class名，值是Boolean值 ⚠️与r-style类似，如果已经存在一个 class 插值了， 那r-class的定义会被覆盖 r-hide 控制节点的 display 样式 Exmaple 如果page !== 'home'为真，则display:none样式会被添加到style中 r-html 即innerHTML插值，注意 XSS 攻击风险 Example Hello 实时编辑 本例双向绑定参考r-model r-animation 动画系统请参考动画章节 "},"faq/":{"url":"faq/","title":"FAQ","keywords":"","body":"常见问题 如何与NEJ UMI系统集成 很多网易同事应该没有直接使用Regular的SPA解决方案[regular-state] 请参考ISSUE: NEJ UMI的集成 #17 Regular的性能(or 脏检查的性能) Regular 由于脏检查的存在，需要一些额外的 注意事项 来达到更好的性能表现。 但在某些情况下，比如 数据全替换场景且页面节点较多 时的频繁更新表现是优于一些竞品框架的， 比如fork自 https://github.com/mathieuancelin/js-repaint-perfs 的这个Case vue2: http://mathieuancelin.github.io/js-repaint-perfs/vue2/ react: http://mathieuancelin.github.io/js-repaint-perfs/react/ regularjs: http://mathieuancelin.github.io/js-repaint-perfs/regularjs/ 在我的电脑上(MacBook Pro 15: 2.2 GHz Intel Core i7、16 GB 1600 MHz DDR3)，三者的fps数据大致是 Vue2: 55 ~ 65 React: 80 ~100 Regular: 130 ~ 140 当然这个场景是明显的对Vue不利，因为Vue的数据是有状态的，全量替换数据需要重新建立依赖关系。 举这个例子，只是为了反驳很多开发者无条件的认为Vue的性能是无可反驳的第一。 由此可见，一个框架很难在所有场景做到表现最好，如果你发现Regular有性能表现特别差的场景，欢迎报Issue给我。 "}}